<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>第二章：开始构建 Firrtl - 从零构建 Chisel</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上一篇讲如何构建基本 Chisel 框架，生成二选一多路选择器的 FIRRTL。本章也从零构建 Firrtl ，来满足生成对应 Verilog 的需求。" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.59.1 with theme even" />


<link rel="canonical" href="http://funwo.ml/build-chisel-from-scratch/post/firrtl-getting-started/" />
<link rel="apple-touch-icon" sizes="180x180" href="/build-chisel-from-scratch/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/build-chisel-from-scratch/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/build-chisel-from-scratch/favicon-16x16.png">
<link rel="manifest" href="/build-chisel-from-scratch/manifest.json">
<link rel="mask-icon" href="/build-chisel-from-scratch/safari-pinned-tab.svg" color="#5bbad5">


<link href="/build-chisel-from-scratch/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="第二章：开始构建 Firrtl" />
<meta property="og:description" content="上一篇讲如何构建基本 Chisel 框架，生成二选一多路选择器的 FIRRTL。本章也从零构建 Firrtl ，来满足生成对应 Verilog 的需求。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://funwo.ml/build-chisel-from-scratch/post/firrtl-getting-started/" />
<meta property="article:published_time" content="2019-12-17T20:26:33+08:00" />
<meta property="article:modified_time" content="2019-12-17T20:26:33+08:00" /><meta property="og:site_name" content="从零构建 Chisel" />
<meta itemprop="name" content="第二章：开始构建 Firrtl">
<meta itemprop="description" content="上一篇讲如何构建基本 Chisel 框架，生成二选一多路选择器的 FIRRTL。本章也从零构建 Firrtl ，来满足生成对应 Verilog 的需求。">


<meta itemprop="datePublished" content="2019-12-17T20:26:33&#43;08:00" />
<meta itemprop="dateModified" content="2019-12-17T20:26:33&#43;08:00" />
<meta itemprop="wordCount" content="15403">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="第二章：开始构建 Firrtl"/>
<meta name="twitter:description" content="上一篇讲如何构建基本 Chisel 框架，生成二选一多路选择器的 FIRRTL。本章也从零构建 Firrtl ，来满足生成对应 Verilog 的需求。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/build-chisel-from-scratch/" class="logo">从零构建 Chisel</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/build-chisel-from-scratch/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/build-chisel-from-scratch/post/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/build-chisel-from-scratch/" class="logo">从零构建 Chisel</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/build-chisel-from-scratch/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/build-chisel-from-scratch/post/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">第二章：开始构建 Firrtl</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-12-17 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#mill-环境搭建">Mill 环境搭建</a></li>
<li><a href="#firrtl-ir">Firrtl IR</a>
<ul>
<li><a href="#基本操作">基本操作</a></li>
<li><a href="#表达式">表达式</a></li>
<li><a href="#语句">语句</a></li>
<li><a href="#宽度">宽度</a></li>
<li><a href="#类型">类型</a></li>
<li><a href="#方向">方向</a></li>
<li><a href="#端口">端口</a></li>
<li><a href="#模块">模块</a></li>
<li><a href="#电路">电路</a></li>
</ul></li>
<li><a href="#把-chisel-ir-转成-firrtl-ir">把 Chisel IR 转成 Firrtl IR</a></li>
<li><a href="#美化输入的-ir-格式">美化输入的 IR 格式</a></li>
<li><a href="#搭建-firrtl-基本框架">搭建 Firrtl 基本框架</a>
<ul>
<li><a href="#电路状态">电路状态</a></li>
<li><a href="#compiler">Compiler</a></li>
<li><a href="#转换">转换</a></li>
<li><a href="#ir-的迭代">IR 的迭代</a>
<ul>
<li><a href="#map-迭代">Map 迭代</a>
<ul>
<li><a href="#statement-ir">Statement IR</a></li>
<li><a href="#expression-ir">Expression IR</a></li>
<li><a href="#type-ir">Type IR</a></li>
<li><a href="#width-ir">Width IR</a></li>
<li><a href="#module-ir">Module IR</a></li>
<li><a href="#circuit-ir">Circuit IR</a></li>
</ul></li>
<li><a href="#for-迭代">for 迭代</a>
<ul>
<li><a href="#statement-ir-1">Statement IR</a></li>
</ul></li>
</ul></li>
<li><a href="#推导类型">推导类型</a></li>
<li><a href="#转成工作-ir">转成工作 IR</a></li>
<li><a href="#解析种类">解析种类</a></li>
<li><a href="#解析方向">解析方向</a></li>
<li><a href="#生成-verilog">生成 Verilog</a>
<ul>
<li><a href="#构建网表">构建网表</a></li>
<li><a href="#构建端口">构建端口</a></li>
<li><a href="#构建语句">构建语句</a></li>
<li><a href="#生成语句">生成语句</a></li>
<li><a href="#辅助方法">辅助方法</a></li>
</ul></li>
<li><a href="#增加转换过程的详细信息">增加转换过程的详细信息</a></li>
</ul></li>
<li><a href="#自定义">自定义</a>
<ul>
<li><a href="#合并冗余的节点">合并冗余的节点</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>上一篇讲如何构建基本 Chisel 框架，生成二选一多路选择器的 <strong>FIRRTL</strong>。本章也从零构建 <strong>Firrtl</strong> ，来满足生成对应 <strong>Verilog</strong> 的需求。</p>

<h1 id="mill-环境搭建">Mill 环境搭建</h1>

<p>删掉原来的 <strong>firrtl</strong> 依赖，增加 <code>firrtl</code> 的 <code>CommonChiselModule</code> 并让 <code>chiselFrontend</code> 和 <code>chisel3</code> 的模块依赖 <code>moduleDeps</code> 都依赖它。 完整的 <code>build.sc</code> 如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">ammonite.ops._</span>

<span class="k">import</span> <span class="nn">mill._</span>
<span class="k">import</span> <span class="nn">mill.scalalib._</span>

<span class="k">trait</span> <span class="nc">CommonChiselModule</span> <span class="k">extends</span> <span class="nc">ScalaModule</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">scalaVersion</span> <span class="k">=</span> <span class="s">&#34;2.12.10&#34;</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">chisel3</span> <span class="k">extends</span> <span class="nc">CommonChiselModule</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">firrtl</span> <span class="k">extends</span> <span class="nc">CommonChiselModule</span>
  <span class="k">object</span> <span class="nc">chiselFrontend</span> <span class="k">extends</span> <span class="nc">CommonChiselModule</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">moduleDeps</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">firrtl</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">moduleDeps</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">firrtl</span><span class="o">,</span> <span class="n">chiselFrontend</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">millSourcePath</span> <span class="k">=</span> <span class="k">super</span><span class="o">.</span><span class="n">millSourcePath</span> <span class="o">/</span> <span class="n">ammonite</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">up</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="firrtl-ir">Firrtl IR</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir -p firrtl/src/ir
$ touch firrtl/src/ir/IR.scala</code></pre></td></tr></table>
</div>
</div>
<p>新建存放 <strong>FIRRTL</strong> <strong>IR</strong> 相关代码的 <code>IR.scal</code> 文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl</span>
<span class="k">package</span> <span class="nn">ir</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">FirrtlNode</span>

<span class="k">trait</span> <span class="nc">HasName</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">IsDeclaration</span> <span class="k">extends</span> <span class="nc">HasName</span></code></pre></td></tr></table>
</div>
</div>
<p><code>FirrtlNode</code> 是 <strong>IR</strong> 的一个基本（根）节点，每种类型的 <strong>IR</strong> 都继承它。</p>

<p><code>HasName</code> 特质定义了字符串类型的名字属性。</p>

<p><code>IsDeclaration</code> 特质归类那些用于声明的 <strong>IR</strong> 类型。</p>

<h2 id="基本操作">基本操作</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">PrimOp</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span></code></pre></td></tr></table>
</div>
</div>
<p>具体的实现是在 <code>play-chisel/firrtl/src/PrimOps.scala</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/PrimOps.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/PrimOps.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl</span>

<span class="k">import</span> <span class="nn">firrtl.ir._</span>

<span class="k">object</span> <span class="nc">PrimOps</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Not</span> <span class="k">extends</span> <span class="nc">PrimOp</span> <span class="o">{</span> <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&#34;not&#34;</span> <span class="o">}</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">And</span> <span class="k">extends</span> <span class="nc">PrimOp</span> <span class="o">{</span> <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&#34;and&#34;</span> <span class="o">}</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Or</span> <span class="k">extends</span> <span class="nc">PrimOp</span> <span class="o">{</span> <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&#34;or&#34;</span> <span class="o">}</span>

  <span class="k">private</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">builtinPrimOps</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">PrimOp</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Seq</span><span class="o">(</span><span class="nc">Not</span><span class="o">,</span> <span class="nc">And</span><span class="o">,</span> <span class="nc">Or</span><span class="o">)</span>
  <span class="k">private</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">strToPrimOp</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">PrimOp</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">builtinPrimOps</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="n">op</span> <span class="k">:</span> <span class="kt">PrimOp</span><span class="o">=&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">toString</span> <span class="o">-&gt;</span> <span class="n">op</span> <span class="o">}.</span><span class="n">toMap</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">fromString</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">PrimOp</span> <span class="o">=</span> <span class="n">strToPrimOp</span><span class="o">(</span><span class="n">op</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里实现了三个位操作：与或非。</p>

<p><code>builtinPrimOps</code> 数组是存放了定义好的基本操作，<code>strToPrimOp</code> 把定义好的基本操作对象跟它的字符串表示关联成映射关系 <strong>Map</strong>，<code>fromString</code> 根据字符串名字找到对应的基本操作对象。</p>

<h2 id="表达式">表达式</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expression</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Reference</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span> <span class="k">with</span> <span class="nc">HasName</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">DoPrim</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="kt">PrimOp</span><span class="o">,</span> <span class="n">args</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Expression</span><span class="o">],</span> <span class="n">consts</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">],</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span></code></pre></td></tr></table>
</div>
</div>
<p>这里定义了两种表达式：引用和运算。</p>

<p>引用类型包含了引用名字和引用类型两个信息，运算表达式包含了操作符、参数、常量和类型。</p>

<h2 id="语句">语句</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Statement</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">DefNode</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Statement</span> <span class="k">with</span> <span class="nc">IsDeclaration</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Block</span><span class="o">(</span><span class="n">stmts</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Statement</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Statement</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Connect</span><span class="o">(</span><span class="n">loc</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">,</span> <span class="n">expr</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Statement</span></code></pre></td></tr></table>
</div>
</div>
<p>这里定义了三种语句：节点语句、语句块和连接语句。</p>

<p>节点语句包含了名字和对应的表达式，语句块包含语句列表，连接语句包含了连接的左值和右值表达式。</p>

<h2 id="宽度">宽度</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Width</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span>

<span class="k">object</span> <span class="nc">IntWidth</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">maxCached</span> <span class="k">=</span> <span class="mi">1024</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">IntWidth</span><span class="o">](</span><span class="n">maxCached</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntWidth</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="n">maxCached</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">i</span> <span class="k">=</span> <span class="n">width</span><span class="o">.</span><span class="n">toInt</span>
      <span class="k">var</span> <span class="n">w</span> <span class="k">=</span> <span class="n">cache</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="n">eq</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">w</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">IntWidth</span><span class="o">(</span><span class="n">width</span><span class="o">)</span>
        <span class="n">cache</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="n">w</span>
      <span class="o">}</span>
      <span class="n">w</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">new</span> <span class="nc">IntWidth</span><span class="o">(</span><span class="n">width</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">IntWidth</span><span class="o">(</span><span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Width</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">UnknownWidth</span> <span class="k">extends</span> <span class="nc">Width</span></code></pre></td></tr></table>
</div>
</div>
<p><code>object IntWidth</code> 会缓存住 0 到 1024 的数值，这样每次遇到这个范围的数值，只会创建一次对应宽度数值的 <code>class IntWidth</code>。</p>

<p><code>UnknownWidth</code> 没有宽度值。</p>

<h2 id="类型">类型</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Type</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">GroundType</span> <span class="k">extends</span> <span class="nc">Type</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">UIntType</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">GroundType</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">UnknownType</span> <span class="k">extends</span> <span class="nc">Type</span></code></pre></td></tr></table>
</div>
</div>
<p>这里定义了两种类型：整型类型和未知类型。</p>

<h2 id="方向">方向</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Direction</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span>

<span class="k">case</span> <span class="k">object</span> <span class="nc">Input</span> <span class="k">extends</span> <span class="nc">Direction</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Output</span> <span class="k">extends</span> <span class="nc">Direction</span></code></pre></td></tr></table>
</div>
</div>
<p>这里定义了两种方向：输入和输出。</p>

<h2 id="端口">端口</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Port</span><span class="o">(</span>
  <span class="n">name</span>      <span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">direction</span> <span class="k">:</span> <span class="kt">Direction</span><span class="o">,</span>
  <span class="n">tpe</span>       <span class="k">:</span> <span class="kt">Type</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span> <span class="k">with</span> <span class="nc">IsDeclaration</span></code></pre></td></tr></table>
</div>
</div>
<p>端口包含了端口的名字、方向和类型。</p>

<h2 id="模块">模块</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">DefModule</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span> <span class="k">with</span> <span class="nc">IsDeclaration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">name</span> <span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">ports</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Port</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Module</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">ports</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Port</span><span class="o">],</span> <span class="n">body</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">DefModule</span></code></pre></td></tr></table>
</div>
</div>
<p><code>DefModule</code> 是基本的模块类型，包含模块的名字和端口列表。模块分为两种：包含模块体定义的一般模块，以及不包含模块体定义的外部模块（这里先不做介绍）。</p>

<h2 id="电路">电路</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Circuit</span><span class="o">(</span><span class="n">modules</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">DefModule</span><span class="o">],</span> <span class="n">main</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span></code></pre></td></tr></table>
</div>
</div>
<p>电路包含模块列表和模块的名字。</p>

<h1 id="把-chisel-ir-转成-firrtl-ir">把 Chisel IR 转成 Firrtl IR</h1>

<p><strong>Chisel</strong> 默认既生成 <strong>FIRRTL</strong> <code>.fir</code> 文件也会生成 <strong>Verilog</strong> <code>.v</code> 文件。但 <strong>Chisel</strong> 并不是调用 <strong>FIRRTL</strong> 解析 <code>.fir</code> 文件来生成 <strong>Verilog</strong> 文件的，而是内部把 <strong>Chisel</strong> 的电路 <strong>IR</strong> 转成 <strong>Firrtl</strong> 的电路 <strong>IR</strong>，省去了 <strong>FIRRTL</strong> 读取 <code>.fir</code> 文件再解析成 <strong>Firrtl</strong> 的电路 <strong>IR</strong> 过程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/internal/firrtl/Converter.scala</code></pre></td></tr></table>
</div>
</div>
<p>新建 <code>Converter.scala</code> 文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/firrtl/Converter.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3.internal.firrtl</span>

<span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.Queue</span>

<span class="k">import</span> <span class="nn">chisel3._</span>
<span class="k">import</span> <span class="nn">firrtl.</span><span class="o">{</span><span class="n">ir</span> <span class="k">=&gt;</span> <span class="n">fir</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">Converter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">fir.Circuit</span> <span class="o">=</span>
    <span class="n">fir</span><span class="o">.</span><span class="nc">Circuit</span><span class="o">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">convert</span><span class="o">),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>import firrtl.{ir =&gt; fir }</code> 改名是为了跟 <strong>Chisel</strong> 的 <code>ir</code> 区分开来。</p>

<p><code>def convert(circuit: Circuit)</code> 方法是将 <strong>Chisel</strong> 的电路 <strong>IR</strong> 转成 <strong>Firrtl</strong> 的电路 <strong>IR</strong>。</p>

<p><code>circuit.components.map(convert)</code> 是遍历 <strong>Chisel</strong> 的模块 <strong>IR</strong>，一一转成 <strong>Firrtl</strong> 的模块 <strong>IR</strong>，存到 <strong>Firrtl</strong> 的电路 <strong>IR</strong> <code>fir.Circuit</code> 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/firrtl/Converter.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Converter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">component</span><span class="k">:</span> <span class="kt">Component</span><span class="o">)</span><span class="k">:</span> <span class="kt">fir.DefModule</span> <span class="o">=</span> <span class="n">component</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ctx</span> <span class="k">@</span> <span class="nc">DefModule</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">ports</span><span class="o">,</span> <span class="n">cmds</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">fir</span><span class="o">.</span><span class="nc">Module</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">ports</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="n">convert</span><span class="o">(</span><span class="n">p</span><span class="o">)),</span> <span class="n">convert</span><span class="o">(</span><span class="n">cmds</span><span class="o">.</span><span class="n">toList</span><span class="o">))</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def convert(component:Component)</code> 方法是将 <strong>Chisel</strong> 的模块 <strong>IR</strong> 转成 <strong>Firrtl</strong> 的模块 <strong>IR</strong>。</p>

<p>目前 <strong>Chisel</strong> 的模块 <strong>IR</strong> 类型只有 <strong>DefModule</strong> 一种。把它的名字、端口列表和命令列表提取出来，分别转换成对应的 <strong>Firrtl</strong>  <strong>IR</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/firrtl/Converter.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Converter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">port</span><span class="k">:</span> <span class="kt">Port</span><span class="o">,</span> <span class="n">topDir</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span> <span class="o">=</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span><span class="o">)</span><span class="k">:</span> <span class="kt">fir.Port</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">resolvedDir</span> <span class="k">=</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="n">fromParent</span><span class="o">(</span><span class="n">topDir</span><span class="o">,</span> <span class="n">port</span><span class="o">.</span><span class="n">dir</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">dir</span> <span class="k">=</span> <span class="n">resolvedDir</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span> <span class="o">|</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Output</span> <span class="k">=&gt;</span> <span class="n">fir</span><span class="o">.</span><span class="nc">Output</span>
      <span class="k">case</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Flip</span> <span class="o">|</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Input</span> <span class="k">=&gt;</span> <span class="n">fir</span><span class="o">.</span><span class="nc">Input</span>
    <span class="o">}</span>
    <span class="k">val</span> <span class="n">tpe</span> <span class="k">=</span> <span class="n">extractType</span><span class="o">(</span><span class="n">port</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
    <span class="n">fir</span><span class="o">.</span><span class="nc">Port</span><span class="o">(</span><span class="n">port</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">getRef</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">dir</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">extractType</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">Data</span><span class="o">)</span><span class="k">:</span> <span class="kt">fir.Type</span> <span class="o">=</span> <span class="n">data</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">d</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=&gt;</span> <span class="n">fir</span><span class="o">.</span><span class="nc">UIntType</span><span class="o">(</span><span class="n">convert</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="n">width</span><span class="o">))</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def convert(port: Port...)</code> 方法是将 <strong>Chisel</strong> 的端口 <strong>IR</strong> 转成 <strong>Firrtl</strong> 的端口 <strong>IR</strong>。</p>

<p>前面调用该方法的时候 <code>topDir</code> 的参数没有给，默认是 <code>SpecifiedDirection.Unspecified</code>。</p>

<p><code>val dir</code> 是端口在 <strong>Firrtl</strong> 这边的端口方向。</p>

<p><code>val tpe</code> 是端口在 <strong>Firrtl</strong> 这边的类型。</p>

<p><code>def extractType</code> 方法根据数据的类型和方向得到 <strong>Firrtl</strong> 的类型 <strong>IR</strong>。</p>

<p><code>fir.Port</code> 记录下端口的名字、方向和类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/firrtl/Converter.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Converter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">fir.Width</span> <span class="o">=</span> <span class="n">width</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">UnknownWidth</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">fir</span><span class="o">.</span><span class="nc">UnknownWidth</span>
    <span class="k">case</span> <span class="nc">KnownWidth</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">fir</span><span class="o">.</span><span class="nc">IntWidth</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def convert(width: Width)</code> 方法是将 <strong>Chisel</strong> 的宽度 <strong>IR</strong> 转成 <strong>Firrtl</strong> 的宽度 <strong>IR</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/firrtl/Converter.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.Queue</span>

<span class="k">object</span> <span class="nc">Converter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">cmds</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Command</span><span class="o">])</span><span class="k">:</span> <span class="kt">fir.Statement</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nd">@tailrec</span>
    <span class="k">def</span> <span class="n">rec</span><span class="o">(</span><span class="n">acc</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">fir.Statement</span><span class="o">])(</span><span class="n">cmds</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Command</span><span class="o">])</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">fir.Statement</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">cmds</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">acc</span>
      <span class="o">}</span> <span class="k">else</span> <span class="n">convertSimpleCommand</span><span class="o">(</span><span class="n">cmds</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">stmt</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">rec</span><span class="o">(</span><span class="n">acc</span> <span class="k">:</span><span class="kt">+</span> <span class="kt">stmt</span><span class="o">)(</span><span class="n">cmds</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">rec</span><span class="o">(</span><span class="n">acc</span><span class="o">)(</span><span class="n">cmds</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">fir</span><span class="o">.</span><span class="nc">Block</span><span class="o">(</span><span class="n">rec</span><span class="o">(</span><span class="nc">Queue</span><span class="o">.</span><span class="n">empty</span><span class="o">)(</span><span class="n">cmds</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">convertSimpleCommand</span><span class="o">(</span><span class="n">cmd</span><span class="k">:</span> <span class="kt">Command</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">fir.Statement</span><span class="o">]</span> <span class="k">=</span> <span class="n">cmd</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">DefPrim</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">args</span> <span class="k">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="n">map</span> <span class="n">convert</span>
      <span class="k">val</span> <span class="n">expr</span> <span class="k">=</span> <span class="n">fir</span><span class="o">.</span><span class="nc">DoPrim</span><span class="o">(</span><span class="n">convert</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">op</span><span class="o">),</span> <span class="n">args</span><span class="o">,</span> <span class="nc">Seq</span><span class="o">(),</span> <span class="n">fir</span><span class="o">.</span><span class="nc">UnknownType</span><span class="o">)</span>
      <span class="nc">Some</span><span class="o">(</span><span class="n">fir</span><span class="o">.</span><span class="nc">DefNode</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">expr</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Connect</span><span class="o">(</span><span class="n">loc</span><span class="o">,</span> <span class="n">exp</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">Some</span><span class="o">(</span><span class="n">fir</span><span class="o">.</span><span class="nc">Connect</span><span class="o">(</span><span class="n">convert</span><span class="o">(</span><span class="n">loc</span><span class="o">),</span> <span class="n">convert</span><span class="o">(</span><span class="n">exp</span><span class="o">)))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def convert(cmds: Seq[Command])</code> 方法是将 <strong>Chisel</strong> 的命令 <strong>IR</strong> 列表一一转成 <strong>Firrtl</strong> 的语句 <strong>IR</strong>。</p>

<p><code>def rec</code> 是一个递归函数，递归调用 <code>convertSimpleCommand</code> 方法转换每一个 <strong>Chisel</strong> 的命令 <strong>IR</strong>，然后添加到 <code>acc</code> 队列里，最后返回该队列。</p>

<p><code>def convertSimpleCommand</code> 方法是将每个 <strong>Chisel</strong> 的命令 <strong>IR</strong> 转成 <strong>Firrtl</strong> 的语句 <strong>IR</strong>。</p>

<p>目前这里的 <strong>Chisel</strong> 命令 <strong>IR</strong> 只有运算 <code>DefPrim</code> 和连接 <code>Connect</code> 两种。</p>

<p><code>DefPrim</code> 的会先把参数、操作类型转成对应的 <strong>Firrtl</strong> 的参数、操作类型 <strong>IR</strong>，然后再转成 <strong>Firrtl</strong> 的表达式 <strong>IR</strong>，最后再放到 <strong>Firrtl</strong> 的 <code>DefNode</code> <strong>IR</strong> 里。 <strong>注意：</strong> <strong>Chisel</strong> 的 <code>DefPrim</code> 命令 <strong>IR</strong> 对应到 <strong>FIRRTL</strong> 里的是一条 <strong>DoPrim</strong> 表达式 <strong>IR</strong> ，需要放在 <strong>DefNode</strong> 才成为一条 <strong>Firrtl</strong> 的语句 <strong>IR</strong>。</p>

<p><code>Connect</code> 的会把左、右值转成对应的 <strong>FIRRTL</strong> 的表达式 <strong>IR</strong>，最后再放到 <strong>Firrtl</strong> 的 <code>Connect</code> <strong>IR</strong> 里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/firrtl/Converter.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Converter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="kt">PrimOp</span><span class="o">)</span><span class="k">:</span> <span class="kt">fir.PrimOp</span> <span class="o">=</span> <span class="n">firrtl</span><span class="o">.</span><span class="nc">PrimOps</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Arg</span><span class="o">)</span><span class="k">:</span> <span class="kt">fir.Expression</span> <span class="o">=</span> <span class="n">arg</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">convert</span><span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="n">getRef</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Ref</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">fir</span><span class="o">.</span><span class="nc">Reference</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">fir</span><span class="o">.</span><span class="nc">UnknownType</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">ModuleIO</span><span class="o">(</span><span class="n">mod</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">fir</span><span class="o">.</span><span class="nc">Reference</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">fir</span><span class="o">.</span><span class="nc">UnknownType</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def convert(op: PrimOp)</code> 方法是将 <strong>Chisel</strong> 的运算符 <strong>IR</strong> 转成 <strong>Firrtl</strong> 的 <strong>IR</strong> 。</p>

<p><code>def convert(arg: Arg</code> 方法是将 <strong>Chisel</strong> 的参数转成 <strong>Firrtl</strong> 的表达式。</p>

<p><code>Node</code> 是将携带的 <strong>Chisel</strong> 元素提前出来再进行转换。</p>

<p><code>Ref</code> 和 <code>ModuleIO</code> 则都是转成 <strong>Firrtl</strong> 的 <code>Reference</code> 引用类型 <strong>IR</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/Main.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">circuit</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Builder</span><span class="o">.</span><span class="n">build</span><span class="o">(</span><span class="nc">Module</span><span class="o">(</span><span class="k">new</span> <span class="nc">Mux2</span><span class="o">))</span>
  <span class="o">...</span>
  <span class="k">val</span> <span class="n">firrtl</span> <span class="k">=</span> <span class="nc">Converter</span><span class="o">.</span><span class="n">convert</span><span class="o">(</span><span class="n">circuit</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">firrtl</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>调用 <code>Converter.convert</code> 方法把 <strong>Chisel</strong> 的电路 <strong>IR</strong> 转换成 <strong>Firrtl</strong>，运行输出看下效果吧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码01</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap02-01">play-chisel/tree/chap02-01</a></p>

<h1 id="美化输入的-ir-格式">美化输入的 IR 格式</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch src/PrintIR.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/PrintIR.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">playchisel</span>

<span class="k">import</span> <span class="nn">firrtl.</span><span class="o">{</span><span class="n">ir</span> <span class="k">=&gt;</span> <span class="n">fir</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">PrintIR</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">tab</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="s">&#34; &#34;</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">*</span> <span class="n">l</span>
  <span class="k">def</span> <span class="n">m_str</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="s">s&#34;Module: </span><span class="si">${</span><span class="n">name</span><span class="si">}</span><span class="s">&#34;</span>
  <span class="k">def</span> <span class="n">p_str</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">fir.Port</span><span class="o">)</span> <span class="k">=</span> <span class="s">s&#34;Port: </span><span class="si">${</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> </span><span class="si">${</span><span class="n">dir_str</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">direction</span><span class="o">)</span><span class="si">}</span><span class="s"> </span><span class="si">${</span><span class="n">type_str</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">tpe</span><span class="o">)</span><span class="si">}</span><span class="s">&#34;</span>
  <span class="k">def</span> <span class="n">dir_str</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">fir.Direction</span><span class="o">)</span> <span class="k">=</span> <span class="n">d</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">Input</span>  <span class="k">=&gt;</span> <span class="s">&#34;Input&#34;</span>
    <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">Output</span> <span class="k">=&gt;</span> <span class="s">&#34;Output&#34;</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">type_str</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">fir.Type</span><span class="o">)</span> <span class="k">=</span> <span class="n">d</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">UIntType</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="s">s&#34;UInt(</span><span class="si">${</span><span class="n">w_str</span><span class="o">(</span><span class="n">w</span><span class="o">)</span><span class="si">}</span><span class="s">)&#34;</span>
    <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">UnknownType</span> <span class="k">=&gt;</span> <span class="s">&#34;UnknownType&#34;</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">w_str</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">fir.Width</span><span class="o">)</span> <span class="k">=</span> <span class="n">w</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">IntWidth</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&#34;</span><span class="si">$i</span><span class="s">&#34;</span>
    <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">UnknownWidth</span> <span class="k">=&gt;</span> <span class="s">&#34;UnknownWidth&#34;</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">stmt_str</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">fir.Statement</span><span class="o">,</span> <span class="n">l</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">DefNode</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&#34;</span><span class="si">${</span><span class="n">tab</span><span class="o">(</span><span class="n">l</span><span class="o">)</span><span class="si">}</span><span class="s">DefNode: </span><span class="si">$n\n$</span><span class="s">{tab(l+1)}</span><span class="si">${</span><span class="n">e_str</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span><span class="si">}</span><span class="s">&#34;</span>
      <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">Block</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&#34;</span><span class="si">${</span><span class="n">tab</span><span class="o">(</span><span class="n">l</span><span class="o">)</span><span class="si">}</span><span class="s">Block\n&#34;</span> <span class="o">+</span> <span class="o">(</span><span class="n">s</span> <span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">stmt_str</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">}</span> <span class="n">mkString</span> <span class="s">&#34;\n&#34;</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">Connect</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="s">s&#34;</span><span class="si">${</span><span class="n">tab</span><span class="o">(</span><span class="n">l</span><span class="o">)</span><span class="si">}</span><span class="s">Connect\n</span><span class="si">${</span><span class="n">tab</span><span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span><span class="si">}${</span><span class="n">e_str</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span><span class="si">}</span><span class="s"> </span><span class="si">${</span><span class="n">e_str</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span><span class="si">}</span><span class="s">&#34;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">e_str</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">fir.Expression</span><span class="o">,</span> <span class="n">l</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">Reference</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&#34;Reference(</span><span class="si">${</span><span class="n">n</span><span class="si">}</span><span class="s">: </span><span class="si">${</span><span class="n">type_str</span><span class="o">(</span><span class="n">t</span><span class="o">)</span><span class="si">}</span><span class="s">)&#34;</span>
      <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">DoPrim</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="n">const</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="s">s&#34;DoPrim\n</span><span class="si">${</span><span class="n">tab</span><span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span><span class="si">}${</span><span class="n">op</span><span class="si">}</span><span class="s">\n</span><span class="si">${</span><span class="n">tab</span><span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span><span class="si">}</span><span class="s">&#34;</span>      <span class="o">+</span>
        <span class="o">(</span><span class="n">args</span> <span class="n">map</span> <span class="o">{</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">e_str</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)}</span> <span class="n">mkString</span> <span class="s">&#34;, &#34;</span><span class="o">)</span> <span class="o">+</span>
        <span class="s">s&#34;\n</span><span class="si">${</span><span class="n">tab</span><span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span><span class="si">}${</span><span class="n">type_str</span><span class="o">(</span><span class="n">tpe</span><span class="o">)</span><span class="si">}</span><span class="s">&#34;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">print_fir</span><span class="o">(</span><span class="n">ast</span><span class="k">:</span> <span class="kt">fir.Circuit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Circuit: </span><span class="si">${</span><span class="n">ast</span><span class="o">.</span><span class="n">main</span><span class="si">}</span><span class="s">&#34;</span><span class="o">)</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">modules</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=&gt;</span>
      <span class="n">print</span><span class="o">(</span><span class="n">tab</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
      <span class="n">println</span><span class="o">(</span><span class="n">m_str</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="o">))</span>
      <span class="n">m</span><span class="o">.</span><span class="n">ports</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">p</span> <span class="k">=&gt;</span>
        <span class="n">print</span><span class="o">(</span><span class="n">tab</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
        <span class="n">println</span><span class="o">(</span><span class="n">p_str</span><span class="o">(</span><span class="n">p</span><span class="o">))</span>
      <span class="o">}</span>
      <span class="n">m</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">fir</span><span class="o">.</span><span class="nc">Module</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">body</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">stmt_str</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/Main.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">PrintIR._</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="n">print_fir</span><span class="o">(</span><span class="n">firrtl</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">IntWidth</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">IntWidth</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="n">width</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码02</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap02-02">play-chisel/tree/chap02-02</a></p>

<h1 id="搭建-firrtl-基本框架">搭建 Firrtl 基本框架</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/Utils.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Utils.scala
</span><span class="c1"></span>
<span class="k">package</span> <span class="nn">firrtl</span>

<span class="k">object</span> <span class="nc">Utils</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">getThrowable</span><span class="o">(</span><span class="n">maybeException</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">],</span> <span class="n">first</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">maybeException</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">t</span> <span class="k">=</span> <span class="n">e</span><span class="o">.</span><span class="n">getCause</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">getThrowable</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">t</span><span class="o">),</span> <span class="n">first</span><span class="o">)</span>
          <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">t</span>
          <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="n">e</span>
        <span class="o">}</span>
      <span class="o">}</span>
      <span class="k">case</span> <span class="nc">None</span> <span class="o">|</span> <span class="kc">null</span> <span class="k">=&gt;</span> <span class="kc">null</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">throwInternalError</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="o">,</span> <span class="n">exception</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Exception</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">throwable</span> <span class="k">=</span> <span class="n">getThrowable</span><span class="o">(</span><span class="n">exception</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">string</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;\n&#34;</span> <span class="k">else</span> <span class="n">message</span>
    <span class="n">error</span><span class="o">(</span><span class="s">&#34;Internal Error! %sPlease file an issue at https://github.com/ucb-bar/firrtl/issues&#34;</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="n">string</span><span class="o">),</span> <span class="n">throwable</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">error</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">cause</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">FirrtlInternalException</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">cause</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/FirrtlException.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/FirrtlException.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl</span>

<span class="k">private</span><span class="o">[</span><span class="kt">firrtl</span><span class="o">]</span> <span class="k">class</span> <span class="nc">FirrtlInternalException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">cause</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Exception</span><span class="o">(</span><span class="n">message</span><span class="o">,</span> <span class="n">cause</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<p>修改下 <code>Main.scala</code>，调用 <code>Firrtl</code> 的 <code>VerilogCompiler</code> 把 <strong>Firrtl</strong> <strong>IR</strong> 表示的电路转成 <strong>Verilog</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">firrtl.</span><span class="o">{</span><span class="nc">VerilogCompiler</span><span class="o">,</span> <span class="nc">CircuitState</span><span class="o">,</span> <span class="nc">ChirrtlForm</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">java.io.</span><span class="o">{</span><span class="nc">File</span><span class="o">,</span> <span class="nc">FileWriter</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">val</span> <span class="n">state</span> <span class="k">=</span> <span class="nc">CircuitState</span><span class="o">(</span><span class="n">firrtl</span><span class="o">,</span> <span class="nc">ChirrtlForm</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">compiler</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VerilogCompiler</span>
  <span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">compiler</span><span class="o">.</span><span class="n">compile</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>CircuitState</code> 是存放 <strong>Firrtl</strong> 电路 <strong>IR</strong> 和当前电路 <strong>IR</strong> 处于哪个编译阶段的状态。</p>

<p><code>compiler.compile</code> 方法是将其编译成 <strong>Verilog</strong>。</p>

<h2 id="电路状态">电路状态</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/Compiler.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Compiler.scala
</span><span class="c1"></span>
<span class="k">package</span> <span class="nn">firrtl</span>

<span class="k">import</span> <span class="nn">firrtl.ir.Circuit</span>
<span class="k">import</span> <span class="nn">firrtl.Utils.throwInternalError</span>
<span class="k">import</span> <span class="nn">firrtl.options.TransformLike</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">CircuitState</span><span class="o">(</span>
  <span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">,</span>
  <span class="n">form</span><span class="k">:</span> <span class="kt">CircuitForm</span><span class="o">,</span>
<span class="o">)</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">CircuitForm</span><span class="o">(</span><span class="k">private</span> <span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">CircuitForm</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">CircuitForm</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">that</span><span class="o">.</span><span class="n">value</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">ChirrtlForm</span> <span class="k">extends</span> <span class="nc">CircuitForm</span><span class="o">(</span><span class="n">value</span> <span class="k">=</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">HighForm</span> <span class="k">extends</span> <span class="nc">CircuitForm</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">MidForm</span> <span class="k">extends</span> <span class="nc">CircuitForm</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">LowForm</span> <span class="k">extends</span> <span class="nc">CircuitForm</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">UnknownForm</span> <span class="k">extends</span> <span class="nc">CircuitForm</span><span class="o">(-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">CircuitForm</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&#34;Illegal to compare UnknownForm&#34;</span><span class="o">);</span> <span class="mi">0</span> <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>CircuitState</code> 包含了电路 <strong>IR</strong> <code>circuit: Circuit</code> 和电路当前的状态 <code>form: CircuitForm</code> 。</p>

<p>电路的状态是可以比较的对象，因为继承了 <code>Ordered[CircuitForm]</code>，比较的方法是对比内部的整型数值 <code>private val value: Int</code>。</p>

<p>高级的形式是低级形式语法的超集，高级往低级转成的过程加入更多的限制条件。由大到小、由高级的形式到低级的 <strong>Verilog</strong> 形式依次是：</p>

<ul>
<li><code>ChirrtlForm</code> <strong>Chisel</strong> 生成的 <strong>IR</strong>；</li>
<li><code>HighForm</code> 由 <code>ChirrtlForm</code> 转成的标准 <strong>FIRRTL</strong> 语法，去掉了 <strong>Chisel</strong> 扩展的语法；</li>
<li><code>MidForm</code> 比 <code>HighForm</code> 多加了三个限制 <strong>所有的宽度必须显式地标明</strong>、<strong>所有的 when 语句必须移除</strong> 和 <strong>每个元素只有一个赋值来源</strong>；</li>
<li><code>LowForm</code> 比 <code>MidForm</code> 多加了两个限制 <strong>所有的集合类型 vector/bundle 必须移除</strong> 和 <strong>所有隐氏的截位必须显式</strong>。</li>
<li><code>UnknownForm</code> 是个特殊的形式，表明当前的操作不会改变当前的形式。</li>
</ul>

<p>因此 <code>UnknownForm</code> 是不具备比较性的。</p>

<h2 id="compiler">Compiler</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/LoweringCompiler.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/LoweringCompiler.scala
</span><span class="c1"></span>
<span class="k">package</span> <span class="nn">firrtl</span>

<span class="k">import</span> <span class="nn">CompilerUtils.getLoweringTransforms</span>

<span class="k">class</span> <span class="nc">VerilogCompiler</span> <span class="k">extends</span> <span class="nc">Compiler</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">emitter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VerilogEmitter</span>
  <span class="k">def</span> <span class="n">transforms</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Transform</span><span class="o">]</span> <span class="k">=</span> <span class="n">getLoweringTransforms</span><span class="o">(</span><span class="nc">ChirrtlForm</span><span class="o">,</span> <span class="nc">LowForm</span><span class="o">)</span> <span class="o">++</span>
    <span class="nc">Seq</span><span class="o">(</span><span class="k">new</span> <span class="nc">LowFirrtlOptimization</span><span class="o">)</span> <span class="o">++</span>
    <span class="nc">Seq</span><span class="o">(</span><span class="n">emitter</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>VerilogCompiler</code> 继承自 <code>Compiler</code>，需要经过一系列的转换 <code>def transforms</code>，最后再发射（生成) <strong>Verilog</strong> <code>Seq(emitter)</code>。</p>

<p><strong>Chisel</strong> 生成的 <strong>FIRRTL IR</strong> 是 <strong>ChirrtlForm</strong>，通过 <code>getLoweringTransforms</code> 转成 <strong>LowForm</strong>。然后再经过 <code>LowFirrtlOptimization</code> 优化处理后，由 <code>emitter</code> （也就是 <code>VerilogEmitter</code>）生成 <strong>Verilog</strong>。</p>

<p>看下 <code>Compiler</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Compiler.scala
</span><span class="c1"></span><span class="k">trait</span> <span class="nc">Compiler</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">emitter</span><span class="k">:</span> <span class="kt">Emitter</span>
  <span class="k">def</span> <span class="n">transforms</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Transform</span><span class="o">]</span>

  <span class="n">require</span><span class="o">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">,</span>
          <span class="s">s&#34;Compiler transforms for &#39;</span><span class="si">${</span><span class="k">this</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span><span class="si">}</span><span class="s">&#39; must have at least ONE Transform! &#34;</span> <span class="o">+</span>
            <span class="s">&#34;Use IdentityTransform if you need an identity/no-op transform.&#34;</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">compile</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">finalState</span> <span class="k">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">state</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">xform</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">xform</span><span class="o">.</span><span class="n">runTransform</span><span class="o">(</span><span class="n">in</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">finalState</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Compiler</code> 规定了子类必须要有 <code>def emitter</code> 生成最终的文件和 <code>def transforms</code> 一系列的转换，并且不能为空，至少得有一个。</p>

<p><code>def compile(state: CircuitState)</code> 方法是将当前的电路状态 <code>state</code> 按顺序地一个传给下一个 <code>transforms</code> 列表里具体的转换对象，返回最终的状态。</p>

<p>接下来看下 <code>Transform</code> 是怎么定义的，转成的过程如何。</p>

<h2 id="转换">转换</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir -p firrtl/src/options
$ touch firrtl/src/options/Phase.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">//  play-chisel/firrtl/src/options/Phase.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl.options</span>

<span class="k">trait</span> <span class="nc">TransformLike</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>

  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>trait TransformLike</code> 是一个转换的基类，它不指定具体的类型，而是泛型变量 <code>A</code>。</p>

<p><code>transform</code> 方法是将 <code>a: A</code> 处理过之后，尽管改变了其中的内容，但还是返回同样的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Compiler.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Transform</span> <span class="k">extends</span> <span class="nc">TransformLike</span><span class="o">[</span><span class="kt">CircuitState</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span>
  <span class="k">def</span> <span class="n">inputForm</span><span class="k">:</span> <span class="kt">CircuitForm</span>
  <span class="k">def</span> <span class="n">outputForm</span><span class="k">:</span> <span class="kt">CircuitForm</span>

  <span class="k">protected</span> <span class="k">def</span> <span class="n">execute</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span> <span class="o">=</span> <span class="n">execute</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">firrtl</span><span class="o">]</span> <span class="k">def</span> <span class="n">prepare</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span> <span class="o">=</span> <span class="n">state</span>

  <span class="k">final</span> <span class="k">def</span> <span class="n">runTransform</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">execute</span><span class="o">(</span><span class="n">prepare</span><span class="o">(</span><span class="n">state</span><span class="o">))</span>

    <span class="nc">CircuitState</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="n">circuit</span><span class="o">,</span> <span class="n">result</span><span class="o">.</span><span class="n">form</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">trait</span> <span class="nc">Emitter</span> <span class="k">extends</span> <span class="nc">Transform</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">outputSuffix</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Transform</code> 是将一个电路状态 <code>CircuitState</code> 转换成另一个电路状态。</p>

<p><code>inputForm</code> 和 <code>outputForm</code> 是指定转换的输入和输出的形式分别是什么。</p>

<p><code>def runTransform</code> 、<code>def execute</code>和<code>def prepare</code> 都是一些进行转换的方法，只是执行顺序不同。</p>

<p><code>Emitter</code> 是一种特殊的转换，一般是放在最后生成文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Compiler.scala
</span><span class="c1"></span><span class="k">trait</span> <span class="nc">SeqTransformBased</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">transforms</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Transform</span><span class="o">]</span>
  <span class="k">protected</span> <span class="k">def</span> <span class="n">runTransforms</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span> <span class="o">=</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">state</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">xform</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xform</span><span class="o">.</span><span class="n">runTransform</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">SeqTransform</span> <span class="k">extends</span> <span class="nc">Transform</span> <span class="k">with</span> <span class="nc">SeqTransformBased</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">execute</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ret</span> <span class="k">=</span> <span class="n">runTransforms</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
    <span class="nc">CircuitState</span><span class="o">(</span><span class="n">ret</span><span class="o">.</span><span class="n">circuit</span><span class="o">,</span> <span class="n">outputForm</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>SeqTransform</code> 是转换序列，经过封装之后，<code>def execute</code> 就是执行了一系列放在 <code>def transforms</code> 里的转换对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Compiler.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">CompilerUtils</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">getLoweringTransforms</span><span class="o">(</span><span class="n">inputForm</span><span class="k">:</span> <span class="kt">CircuitForm</span><span class="o">,</span> <span class="n">outputForm</span><span class="k">:</span> <span class="kt">CircuitForm</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Transform</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">outputForm</span> <span class="o">&gt;=</span> <span class="n">inputForm</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Seq</span><span class="o">.</span><span class="n">empty</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">inputForm</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">ChirrtlForm</span> <span class="k">=&gt;</span>
          <span class="nc">Seq</span><span class="o">(</span><span class="k">new</span> <span class="nc">ChirrtlToHighFirrtl</span><span class="o">)</span> <span class="o">++</span> <span class="n">getLoweringTransforms</span><span class="o">(</span><span class="nc">HighForm</span><span class="o">,</span> <span class="n">outputForm</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">HighForm</span> <span class="k">=&gt;</span>
          <span class="nc">Seq</span><span class="o">(</span><span class="k">new</span> <span class="nc">IRToWorkingIR</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ResolveAndCheck</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HighFirrtlToMiddleFirrtl</span><span class="o">)</span> <span class="o">++</span>
              <span class="n">getLoweringTransforms</span><span class="o">(</span><span class="nc">MidForm</span><span class="o">,</span> <span class="n">outputForm</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">MidForm</span> <span class="k">=&gt;</span> <span class="nc">Seq</span><span class="o">(</span><span class="k">new</span> <span class="nc">MiddleFirrtlToLowFirrtl</span><span class="o">)</span> <span class="o">++</span> <span class="n">getLoweringTransforms</span><span class="o">(</span><span class="nc">LowForm</span><span class="o">,</span> <span class="n">outputForm</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">LowForm</span> <span class="k">=&gt;</span> <span class="n">throwInternalError</span><span class="o">(</span><span class="s">&#34;getLoweringTransforms - LowForm&#34;</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">UnknownForm</span> <span class="k">=&gt;</span> <span class="n">throwInternalError</span><span class="o">(</span><span class="s">&#34;getLoweringTransforms - UnknownForm&#34;</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>object CompilerUtils</code> 里的 <code>getLoweringTransforms</code> 是根据当前的输入和输出形式，生成一些转换对象，需要经过它们才能完成转换。</p>

<p><code>ChirrtlForm</code> 需要经过 <code>ChirrtlToHighFirrtl</code> 才能到 <code>HighForm</code> 形式，<code>HighForm</code> 需要经过 <code>IRToWorkingIR</code>、<code>ResolveAndCheck</code> 和 <code>HighFirrtlToMiddleFirrtl</code> 才能到 <code>MidForm</code> 形式；<code>MidForm</code> 需要经过 <code>MiddleFirrtlToLowFirrtl</code> 才能到 <code>LowForm</code> 形式。</p>

<p>当输出形式的级别大于等于输入的级别时就停下来了。</p>

<p>这里罗列下这些形式的定义，有些形式的 <code>def transforms = Seq()</code> 表示暂时不实现转换，先占个位置，没有起到实际的作用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/LoweringCompiler.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">CoreTransform</span> <span class="k">extends</span> <span class="nc">SeqTransform</span>

<span class="k">class</span> <span class="nc">ChirrtlToHighFirrtl</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">inputForm</span> <span class="k">=</span> <span class="nc">ChirrtlForm</span>
  <span class="k">def</span> <span class="n">outputForm</span> <span class="k">=</span> <span class="nc">HighForm</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
  <span class="c1">// def transforms = Seq(
</span><span class="c1"></span>  <span class="c1">// passes.CInferTypes,
</span><span class="c1"></span>  <span class="c1">// )
</span><span class="c1"></span><span class="o">}</span>
<span class="k">class</span> <span class="nc">IRToWorkingIR</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">inputForm</span> <span class="k">=</span> <span class="nc">HighForm</span>
  <span class="k">def</span> <span class="n">outputForm</span> <span class="k">=</span> <span class="nc">HighForm</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
  <span class="c1">// def transforms = Seq(passes.ToWorkingIR)
</span><span class="c1"></span><span class="o">}</span>
<span class="k">class</span> <span class="nc">ResolveAndCheck</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">inputForm</span> <span class="k">=</span> <span class="nc">HighForm</span>
  <span class="k">def</span> <span class="n">outputForm</span> <span class="k">=</span> <span class="nc">HighForm</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
  <span class="c1">// def transforms = Seq(
</span><span class="c1"></span>  <span class="c1">//   passes.ResolveKinds,
</span><span class="c1"></span>  <span class="c1">//   passes.ResolveFlows,
</span><span class="c1"></span>  <span class="c1">// )
</span><span class="c1"></span><span class="o">}</span>
<span class="k">class</span> <span class="nc">HighFirrtlToMiddleFirrtl</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">inputForm</span> <span class="k">=</span> <span class="nc">HighForm</span>
  <span class="k">def</span> <span class="n">outputForm</span> <span class="k">=</span> <span class="nc">MidForm</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">MiddleFirrtlToLowFirrtl</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">inputForm</span> <span class="k">=</span> <span class="nc">MidForm</span>
  <span class="k">def</span> <span class="n">outputForm</span> <span class="k">=</span> <span class="nc">LowForm</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">LowFirrtlOptimization</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">inputForm</span> <span class="k">=</span> <span class="nc">LowForm</span>
  <span class="k">def</span> <span class="n">outputForm</span> <span class="k">=</span> <span class="nc">LowForm</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>CoreTransform</code> 这里只是 <code>SeqTransform</code> 的一个别称，可以看作是一个分组，每个分类里包含具体的转换对象 <code>def transforms</code>。</p>

<p>目前这里仅介绍 <code>ChirrtlToHighFirrtl</code> 分类下的 <code>passes.CInferTypes</code>，<code>IRToWorkingIR</code> 分类下的 <code>passes.ToWorkingIR</code> 和 <code>ResolveAndCheck</code> 分类下的 <code>passes.ResolveKinds</code> 和 <code>passes.ResolveFlows</code>。（先注释掉，后面讲到对应的时候再拿掉注释）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir -p firrtl/src/passes
$ touch firrtl/src/passes/Passes.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/Passes.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl.passes</span>

<span class="k">import</span> <span class="nn">firrtl._</span>
<span class="k">import</span> <span class="nn">firrtl.ir._</span>
<span class="k">import</span> <span class="nn">firrtl.Utils._</span>
<span class="k">import</span> <span class="nn">firrtl.Mappers._</span>

<span class="k">trait</span> <span class="nc">Pass</span> <span class="k">extends</span> <span class="nc">Transform</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">inputForm</span><span class="k">:</span> <span class="kt">CircuitForm</span> <span class="o">=</span> <span class="nc">UnknownForm</span>
  <span class="k">def</span> <span class="n">outputForm</span><span class="k">:</span> <span class="kt">CircuitForm</span> <span class="o">=</span> <span class="nc">UnknownForm</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span>
  <span class="k">def</span> <span class="n">execute</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="n">form</span><span class="o">,</span> <span class="n">inputForm</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">UnknownForm</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="n">circuit</span><span class="o">)</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">UnknownForm</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="n">circuit</span><span class="o">)</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">=&gt;</span>
        <span class="n">error</span><span class="o">(</span><span class="s">s&#34;[</span><span class="si">$name</span><span class="s">]: Input form must be lower or equal to </span><span class="si">$inputForm</span><span class="s">. Got </span><span class="si">${</span><span class="n">state</span><span class="o">.</span><span class="n">form</span><span class="si">}</span><span class="s">&#34;</span><span class="o">)</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="n">circuit</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="nc">CircuitState</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">outputForm</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/Emitter.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Emitter.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl</span>

<span class="k">class</span> <span class="nc">VerilogEmitter</span> <span class="k">extends</span> <span class="nc">SeqTransform</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">inputForm</span> <span class="k">=</span> <span class="nc">LowForm</span>
  <span class="k">def</span> <span class="n">outputForm</span> <span class="k">=</span> <span class="nc">LowForm</span>
  <span class="k">val</span> <span class="n">outputSuffix</span> <span class="k">=</span> <span class="s">&#34;.v&#34;</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="ir-的迭代">IR 的迭代</h2>

<p>先以一个小的例子讲解隐式转换，后面会需要到这方面的知识。</p>

<p>随便在哪里新建一个文件 <code>foo.scala</code>，写入以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Foo</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Bar</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">printBar</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Bar</span><span class="o">)</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="o">)</span>

  <span class="k">object</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">fromInt</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Bar</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">printBar</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ scala foo.scala</code></pre></td></tr></table>
</div>
</div>
<p>输出以下错误信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">foo.scala:10: error: <span class="nb">type</span> mismatch<span class="p">;</span>
 found   : Int<span class="o">(</span><span class="m">10</span><span class="o">)</span>
 required: Main.Bar
  printBar<span class="o">(</span><span class="m">10</span><span class="o">)</span>
           ^</code></pre></td></tr></table>
</div>
</div>
<p>可以看到，当隐式转换放在一个 <code>object</code> 里，和 <code>printBar(10)</code> 作用域就不在一起了，编译器也就无法找到隐式声明进行隐式转换。</p>

<p>这次做个小修改，把 <code>object Car</code> 改成 <code>object Bar</code>。再运行一遍，发现结果对了，输出了 <code>10</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="mi">10</span></code></pre></td></tr></table>
</div>
</div>
<p>发现编译器在寻找隐式转换的时候，会去转换到的目标类型的 <code>object</code> 作用域里寻找。这个例子里，<code>printBar</code> 的参数类型是 <code>Bar</code>，而传递的参数是 <code>Int</code> 类型，编译器会去寻找把 <code>Int</code> 转成 <code>Bar</code> 类型的隐式函数。它会去 <code>Bar</code> 类型的 <code>object Bar</code> 里面寻找，找到了 <code>implicit def fromInt</code> 方法。</p>

<p>再扩展个稍微复杂的例子。</p>

<p>对自定义类 <code>Statement</code> 重载 <code>map</code> 方法。<code>Statement</code> 类有两个属性，<code>Int</code> 整型类型表示的数值 <code>num</code>和 <code>String</code> 字符串类型表示的字符串 <code>str</code>。 重载的 <code>map</code> 方法根据传给 <code>map</code> 方法的参数类型，自己找到对应的属性进行操作，例如针对 <code>Int</code> 类型的函数就改变 <code>num</code> 属性，针对 <code>String</code> 类型的函数就改变 <code>str</code> 属性。重载的 <code>map</code> 方法不在 <code>Statement</code> 类里面定义，而是通过隐式类的方式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Foo</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">addTwo</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="k">def</span> <span class="n">addStr</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&#34; world&#34;</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">Statement</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">mapInt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">num</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">num</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">mapStr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">str</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">str</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">trait</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">object</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forInt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">mapInt</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forStr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">mapStr</span> <span class="n">f</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">StmtMap</span><span class="o">(</span><span class="k">val</span> <span class="nc">_stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span> <span class="o">=&gt;</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">StmtMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">_stmt</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">stmt</span> <span class="k">=</span> <span class="nc">Statement</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="s">&#34;Hello&#34;</span><span class="o">)</span>

  <span class="n">println</span><span class="o">(</span><span class="s">&#34;Before: &#34;</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">stmt</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">newStmt</span> <span class="k">=</span> <span class="n">stmt</span> <span class="n">map</span> <span class="n">addTwo</span> <span class="n">map</span> <span class="n">addStr</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&#34;After: &#34;</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">newStmt</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>case class Statement(num: Int, str: String)</code> 类除了定义两个属性之外，还分别定义了针对这个两个属性进行操作的方法 <code>def mapInt</code> 和 <code>def mapStr</code>。</p>

<p><code>def mapInt</code> 方法用函数 <code>f</code> 改变 <code>num</code> 属性，<code>def mapStr</code> 方法用函数 <code>f</code> 改变 <code>str</code> 属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">implicit</span> <span class="k">class</span> <span class="nc">StmtMap</span><span class="o">(</span><span class="k">val</span> <span class="nc">_stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span> <span class="o">=&gt;</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">StmtMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">_stmt</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当执行 <code>stmt map addTwo</code> 的时候， <code>Statement</code> 类型没有定义 <code>map</code> 方法，此时编译器就会去找隐式类 <code>implicit class</code> 构造函数的参数类型是 <code>Statement</code> 的。找到之后，就把 <code>stmt</code> 作为 <code>val _stmt</code> 传参进隐式类里，再找名字叫 <code>map</code> 的方法来调用。 <code>addTwo</code> 方法作为 <code>map</code> 方法的参数 <code>f</code>。</p>

<p><code>(implicit magnet: (T =&gt; T) =&gt; StmtMagnet)</code> 是隐式的参数，编译器会在调用 <code>def map</code> 时自动加上。例如这里的 <code>stmt map addTwo</code>，<code>T</code> 就会自动推导成 <code>Int</code> 类型，也就是转成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">addTwo</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span> <span class="o">=&gt;</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">StmtMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> 
  <span class="n">magnet</span><span class="o">(</span><span class="n">addTwo</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">stmt</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<p><code>magnet(addTwo)</code> 是执行了参数 <code>implicit magnet: (T=&gt;T) =&gt; StmtMagnet</code>，相当于调用了函数 <code>magnet</code>，参数是 <code>addTwo</code>，返回的结果类型是 <code>StmtMagnet</code>。编译器会去寻找能把 <code>addTwo</code>的 <code>Int =&gt; Int</code> 函数类型转成 <code>StmtMagnet</code> 的方法。</p>

<p>编译器在 <code>object StmtMagnet</code>里找到类型匹配的隐式方法 <code>implicit def forInt</code>，那么就会调用该方法生成一个新的 <code>StmtMagnet</code> 类型的对象，它重载了 <code>map</code> 方法，变成调用 <code>Statement</code> 类型的参数 <code>stmt</code> 的 <code>mapInt</code> 方法。</p>

<p><code>magnet(addTwo)</code> 仅仅是生成了重载 <code>map</code> 方法后的 <code>Statement</code> 对象，还得调用该方法 <code>magnet(addTwo).map(stmt)</code>。相当于 <code>stmt mapInt addTwo</code>。</p>

<p>其实做了这么多事情，跟直接写 <code>stmt mapInt addTwo</code> 是一样的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala">  <span class="k">val</span> <span class="n">newStmt</span> <span class="k">=</span> <span class="n">stmt</span> <span class="n">map</span> <span class="n">addTwo</span> <span class="n">map</span> <span class="n">addStr</span>
  <span class="c1">// 等价于
</span><span class="c1"></span>  <span class="k">val</span> <span class="n">newStmt</span> <span class="k">=</span> <span class="n">stmt</span> <span class="n">mapInt</span> <span class="n">addTwo</span> <span class="n">mapStr</span> <span class="n">addStr</span></code></pre></td></tr></table>
</div>
</div>
<p>好处是一旦定义好之后，每次写 <code>map</code> 就好了，不管是 <code>Int</code> 类型还是 <code>String</code> 类型。坏处就是读起来不直观，需要自己推导出，当 <code>map</code> 针对的 <code>Int</code> 类型时，实际上是调用 <code>mapInt</code> 方法，针对 <code>String</code> 类型时，实际上调用的是 <code>mapStr</code> 方法。</p>

<p>运行结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">Before: 
Statement<span class="o">(</span><span class="m">5</span>,Hello<span class="o">)</span>
After: 
Statement<span class="o">(</span><span class="m">7</span>,Hello world<span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<p>在对 <strong>Firrtl</strong> 的 <strong>IR</strong> 进行迭代处理过程中，大量地运用这种隐式转换的方法。</p>

<h3 id="map-迭代">Map 迭代</h3>

<p>新建 <code>Mapper.scala</code> 文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/Mapper.scala</code></pre></td></tr></table>
</div>
</div>
<p>下面是 <code>Statement</code> <strong>IR</strong> 的 <code>def map</code> 方法实现。</p>

<h4 id="statement-ir">Statement IR</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Mapper.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl</span>

<span class="k">import</span> <span class="nn">language.implicitConversions</span>
<span class="k">import</span> <span class="nn">firrtl.ir._</span>

<span class="k">object</span> <span class="nc">Mappers</span> <span class="o">{</span>
  <span class="c1">// ********** Stmt Mappers **********
</span><span class="c1"></span>  <span class="k">private</span> <span class="k">trait</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">object</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">mapStmt</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forExp</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">mapExpr</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">mapType</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">mapString</span> <span class="n">f</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">StmtMap</span><span class="o">(</span><span class="k">val</span> <span class="nc">_stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span> <span class="o">=&gt;</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">StmtMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">_stmt</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当对一个 <code>Statement</code> 类型的 <strong>IR</strong> 进行 <code>map</code> 的时： <code>stmt map f</code>，要明白一点，背后实际上根据不同的类型调用了不同的方法。</p>

<ul>
<li><code>String</code> 类型对应 <code>stmt mapString f</code> ；</li>
<li><code>Type</code> 类型对应 <code>stmt mapType f</code> ；</li>
<li><code>Expression</code> 类型对应 <code>stmt mapExpr f</code> ；</li>
<li><code>Statement</code> 类型对应 <code>stmt mapStmt f</code>。</li>
</ul>

<p>看下对应的这些方法，在 <code>Statement</code> <strong>IR</strong> 里是怎么定义的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Statement</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapStmt</span>   <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Statement</span><span class="o">)</span>   <span class="k">:</span> <span class="kt">Statement</span>
  <span class="k">def</span> <span class="n">mapExpr</span>   <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Statement</span>
  <span class="k">def</span> <span class="n">mapType</span>   <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span>             <span class="k">:</span> <span class="kt">Statement</span>
  <span class="k">def</span> <span class="n">mapString</span> <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span>         <span class="k">:</span> <span class="kt">Statement</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>抽象类 <code>Statement</code> 规定了子类必须要有这四种方法，注意这里不管是什么方法，最后的返回值都是 <code>Statement</code> 类型。换句话说，这些方法只是更改了 <code>Statement</code> 里的某种属性，然后返回更改过的 <code>Statement</code> 对象。</p>

<p>目前继承 <code>Statement</code> 的子类有：<code>DefNode</code>、<code>Block</code> 和 <code>Connect</code> 三种，下面分别看下它们是如何实现这些方法的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">DefNode</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Statement</span> <span class="k">with</span> <span class="nc">IsDeclaration</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="n">mapExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="nc">DefNode</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">value</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="n">mapString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="nc">DefNode</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">name</span><span class="o">),</span> <span class="n">value</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>DefNode</code> 只有 <code>String</code> 和 <code>Expression</code> 两种类型的属性 <code>name</code> 和 <code>value</code>。</p>

<p>因此 <code>mapStmt</code> 和 <code>mapType</code> 没有匹配类型的属性，什么也没改变就返回了自身。</p>

<p><code>mapExpr</code> 和 <code>mapString</code> 方法是各自更改了对应类型的属性 <code>f(value)</code> 和 <code>f(name)</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Block</span><span class="o">(</span><span class="n">stmts</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Statement</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Statement</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="nc">Block</span><span class="o">(</span><span class="n">stmts</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">mapExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="n">mapString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Block</code> 只有一个存放 <code>Statement</code> 序列的属性 <code>stmts</code>。</p>

<p>由于 <code>def mapStmt</code> 方法的参数 <code>f</code> 是针对一个 <code>Statement</code> 的函数，要对 <code>stmts</code> 进行 <code>map</code> 迭代，一一代入 <code>f</code> 方法，整体更改 <code>stmts</code> 属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Connect</span><span class="o">(</span><span class="n">loc</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">,</span> <span class="n">expr</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Statement</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="n">mapExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="nc">Connect</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">loc</span><span class="o">),</span> <span class="n">f</span><span class="o">(</span><span class="n">expr</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="n">mapString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="k">this</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>mapExpr</code> 是会调用函数 <code>f</code> 改变两个 <code>Expression</code> 属性：<code>loc: Expression</code> 和 <code>expr: Expression</code>，其他的方法什么也不做返回自身。</p>

<h4 id="expression-ir">Expression IR</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Mapper.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Mappers</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// ********** Expression Mappers **********
</span><span class="c1"></span>  <span class="k">private</span> <span class="k">trait</span> <span class="nc">ExprMagnet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">object</span> <span class="nc">ExprMagnet</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">ExprMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ExprMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">expr</span> <span class="n">mapExpr</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">ExprMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ExprMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">expr</span> <span class="n">mapType</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">ExprMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ExprMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">expr</span> <span class="n">mapWidth</span> <span class="n">f</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">ExprMap</span><span class="o">(</span><span class="k">val</span> <span class="nc">_expr</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span> <span class="o">=&gt;</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ExprMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">_expr</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当对一个 <code>Expression</code> 类型的 <strong>IR</strong> 进行 <code>map</code> 方法时（ <code>expr map f</code>），实际上是根据方法 <code>f</code> 的类型不同调用的方法：</p>

<ul>
<li><code>Expression =&gt; Expression</code> 类型对应 <code>expr mapExpr f</code>；</li>
<li><code>Type =&gt; Type</code> 类型对应 <code>expr mapType f</code>；</li>
<li><code>Width =&gt; Width</code> 类型对应 <code>expr mapWidth f</code>。</li>
</ul>

<p>看下对应的这些方法，在 <code>Expression</code> <strong>IR</strong> 里是怎么定义的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expression</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span>
  <span class="k">def</span> <span class="n">mapWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>抽象类 <code>Expression</code> 规定了子类必须要有这三种方法，注意这里不管是什么方法，最后的返回值都是 <code>Expression</code> 类型。换句话说，这些方法只是更改了 <code>Expression</code> 里的某种属性，然后返回更改过的 <code>Expression</code> 对象。</p>

<p>目前继承 <code>Expression</code> 的子类有：<code>Reference</code> 和 <code>DoPrim</code> 两种，下面分别看下它们是如何实现这些方法的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Reference</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span> <span class="k">with</span> <span class="nc">HasName</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">tpe</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">tpe</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">mapWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="k">this</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Reference</code> 只有 <code>tpe: Type</code> 属性可以更改，因此 <code>mapExpr</code> 和 <code>mapWidth</code> 没有匹配类型的属性，什么也没改变就返回了自身。</p>

<p><code>mapType</code> 方法调用 <code>f</code> 函数更改了 <code>tpe</code> 属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">DoPrim</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="kt">PrimOp</span><span class="o">,</span> <span class="n">args</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Expression</span><span class="o">],</span> <span class="n">consts</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">],</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">args</span> <span class="k">=</span> <span class="n">args</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">tpe</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">tpe</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">mapWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="k">this</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>DoPrim</code> 可以更改的属性有 <code>args: Seq[Expression</code> 和 <code>tpe: Type</code>，因此 <code>mapWidth</code> 没有匹配类型的属性，什么也没改变就返回了自身。</p>

<p><code>mapExpr</code> 和 <code>mapType</code> 方法则分别更改 <code>args</code> 和 <code>tpe</code> 两个属性。</p>

<h4 id="type-ir">Type IR</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Mapper.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Mappers</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// ********** Type Mappers **********
</span><span class="c1"></span>  <span class="k">private</span> <span class="k">trait</span> <span class="nc">TypeMagnet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">object</span> <span class="nc">TypeMagnet</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">TypeMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TypeMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="n">tpe</span> <span class="n">mapType</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">TypeMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TypeMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="n">tpe</span> <span class="n">mapWidth</span> <span class="n">f</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">TypeMap</span><span class="o">(</span><span class="k">val</span> <span class="nc">_tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span> <span class="o">=&gt;</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">TypeMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">_tpe</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当对一个 <code>Type</code> 类型的 <strong>IR</strong> 进行 <code>map</code> 方法时（ <code>tpe map f</code>），实际上是根据方法 <code>f</code> 的类型不同调用的方法：</p>

<ul>
<li><code>Type =&gt; Type</code> 类型对应 <code>expr mapType f</code>；</li>
<li><code>Width =&gt; Width</code> 类型对应 <code>expr mapWidth f</code>。</li>
</ul>

<p>看下对应的这些方法，在 <code>Type</code> <strong>IR</strong> 里是怎么定义的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Type</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span>
  <span class="k">def</span> <span class="n">mapWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>抽象类 <code>Type</code> 规定了子类必须要有这两种方法，注意这里不管是什么方法，最后的返回值都是 <code>Type</code> 类型。换句话说，这些方法只是更改了 <code>Type</code> 里的某种属性，然后返回更改过的 <code>Type</code> 对象。</p>

<p>目前继承 <code>Type</code> 的子类有 <strong>GroundType</strong> 和 <strong>UnknownType</strong> ：</p>

<ul>
<li><strong>GroundType</strong>

<ul>
<li><strong>UIntType</strong></li>
</ul></li>
<li><strong>UnknownType</strong></li>
</ul>

<p>下面分别看下它们是如何实现这些方法的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">GroundType</span> <span class="k">extends</span> <span class="nc">Type</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="k">this</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>GroundType</strong> 子类是没有类型属性的，因此 <code>mapType</code> 方法什么也没修改，就返回了自身。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">UIntType</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">GroundType</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="nc">UIntType</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">width</span><span class="o">))</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>UIntType</code> 的 <code>mapWidth</code> 会调用函数 <code>f</code> 修改宽度属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">object</span> <span class="nc">UnknownType</span> <span class="k">extends</span> <span class="nc">Type</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="n">mapWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=</span> <span class="k">this</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>UnknownType</strong> 没有任何属性，所以方法都是返回自身。</p>

<h4 id="width-ir">Width IR</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Mapper.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Mappers</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// ********** Width Mappers **********
</span><span class="c1"></span>  <span class="k">private</span> <span class="k">trait</span> <span class="nc">WidthMagnet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">object</span> <span class="nc">WidthMagnet</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">WidthMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WidthMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="n">width</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">mapable</span><span class="k">:</span> <span class="kt">HasMapWidth</span> <span class="o">=&gt;</span> <span class="n">mapable</span> <span class="n">mapWidth</span> <span class="n">f</span> <span class="c1">// WIR
</span><span class="c1"></span>        <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span> <span class="n">other</span> <span class="c1">// Standard IR nodes
</span><span class="c1"></span>      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">WidthMap</span><span class="o">(</span><span class="k">val</span> <span class="nc">_width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span> <span class="o">=&gt;</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">WidthMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">_width</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当对一个 <code>Width</code> 类型的 <strong>IR</strong> 进行 <code>map</code> 方法时（ <code>tpe map f</code>），实际上是根据方法 <code>f</code> 的类型不同调用的方法：</p>

<ul>
<li><code>Width =&gt; Width</code> 类型对应 <code>width mapWidth f</code>。</li>
</ul>

<p>看下对应的这些方法，在 <code>Width</code> <strong>IR</strong> 里是怎么定义的。</p>

<p>不是每种 <code>Width</code> 类型都有 <code>mapWidth</code> 方法。只有继承了 <code>HasMapWidth</code> 的才有。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/WIR.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/WIR.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl</span>

<span class="k">import</span> <span class="nn">Utils._</span>
<span class="k">import</span> <span class="nn">firrtl.ir._</span>

<span class="k">private</span><span class="o">[</span><span class="kt">firrtl</span><span class="o">]</span> <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">HasMapWidth</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">MaxWidth</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Width</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Width</span> <span class="k">with</span> <span class="nc">HasMapWidth</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="nc">MaxWidth</span><span class="o">(</span><span class="n">args</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>MaxWidth</code> 是有 <code>mapWidth</code> 方法的，就是调用函数 <code>f</code> 改变它 <code>args: Seq[Width]</code> 属性里的每一个 <code>Width</code> 类型的元素。</p>

<h4 id="module-ir">Module IR</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Mapper.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Mappers</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// ********** Module Mappers **********
</span><span class="c1"></span>  <span class="k">private</span> <span class="k">trait</span> <span class="nc">ModuleMagnet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">module</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">object</span> <span class="nc">ModuleMagnet</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">ModuleMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ModuleMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">module</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="n">module</span> <span class="n">mapStmt</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forPorts</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Port</span> <span class="o">=&gt;</span> <span class="nc">Port</span><span class="o">)</span><span class="k">:</span> <span class="kt">ModuleMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ModuleMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">module</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="n">module</span> <span class="n">mapPort</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ModuleMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ModuleMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">module</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="n">module</span> <span class="n">mapString</span> <span class="n">f</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">ModuleMap</span><span class="o">(</span><span class="k">val</span> <span class="nc">_module</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span> <span class="o">=&gt;</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ModuleMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">_module</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当对一个 <code>Module</code> 类型的 <strong>IR</strong> 进行 <code>map</code> 方法时（ <code>module map f</code>），实际上是根据方法 <code>f</code> 的类型不同调用的方法：</p>

<ul>
<li><code>Statement =&gt; Statement</code> 类型对应 <code>module mapStmt f</code>。</li>
<li><code>Port =&gt; Port</code> 类型对应 <code>module mapPort f</code>。</li>
<li><code>String =&gt; String</code> 类型对应 <code>module mapString f</code>。</li>
</ul>

<p>看下对应的这些方法，在 <code>Module</code> <strong>IR</strong> 里是怎么定义的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">DefModule</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span> <span class="k">with</span> <span class="nc">IsDeclaration</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">mapStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span>
  <span class="k">def</span> <span class="n">mapPort</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Port</span> <span class="o">=&gt;</span> <span class="nc">Port</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span>
  <span class="k">def</span> <span class="n">mapString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>抽象类 <code>DefModule</code> 规定了子类必须要有这三种方法，注意这里不管是什么方法，最后的返回值都是 <code>DefModule</code> 类型。换句话说，这些方法只是更改了 <code>DefModule</code> 里的某种属性，然后返回更改过的 <code>DefModule</code> 对象。</p>

<p>目前继承 <code>DefModule</code> 类型的只有 <code>Module</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Module</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">ports</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Port</span><span class="o">],</span> <span class="n">body</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">DefModule</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">body</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">body</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">mapPort</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Port</span> <span class="o">=&gt;</span> <span class="nc">Port</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">ports</span> <span class="k">=</span> <span class="n">ports</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">mapString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">name</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>mapStmt</code> 调用函数 <code>f</code> 改变的是 <code>body: Statement</code> 属性，<code>mapPort</code> 改变的是 <code>ports: Seq[Port]</code> 属性， <code>mapString</code> 改变的是 <code>name: String</code> 属性。</p>

<h4 id="circuit-ir">Circuit IR</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Mapper.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Mappers</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// ********** Circuit Mappers **********
</span><span class="c1"></span>  <span class="k">private</span> <span class="k">trait</span> <span class="nc">CircuitMagnet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">module</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">object</span> <span class="nc">CircuitMagnet</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forModules</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=&gt;</span> <span class="nc">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CircuitMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="n">circuit</span> <span class="n">mapModule</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CircuitMagnet</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="n">circuit</span> <span class="n">mapString</span> <span class="n">f</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">CircuitMap</span><span class="o">(</span><span class="k">val</span> <span class="nc">_circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span> <span class="o">=&gt;</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">CircuitMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">_circuit</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当对一个 <code>Circuit</code> 类型的 <strong>IR</strong> 进行 <code>map</code> 方法时（ <code>circuit map f</code>），实际上是根据方法 <code>f</code> 的类型不同调用的方法：</p>

<ul>
<li><code>DefModule =&gt; DefModule</code> 类型对应 <code>module mapModule f</code>。</li>
<li><code>String =&gt; String</code> 类型对应 <code>module mapString f</code>。</li>
</ul>

<p>看下对应的这些方法，在 <code>Circuit</code> <strong>IR</strong> 里是怎么定义的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Circuit</span><span class="o">(</span><span class="n">modules</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">DefModule</span><span class="o">],</span> <span class="n">main</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapModule</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=&gt;</span> <span class="nc">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">modules</span> <span class="k">=</span> <span class="n">modules</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">mapString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">main</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">main</span><span class="o">))</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Circuit</code> 的 <code>mapModule</code> 是调用函数 <code>f</code> 修改 <code>modules: Seq[DefModule]</code> 属性里的每一个 <code>DefModule</code> 元素，<code>mapString</code> 是修改 <code>main: String</code> 属性。</p>

<h3 id="for-迭代">for 迭代</h3>

<p><code>foreach</code> 的迭代方式跟 <code>map</code> 的类似，都是会根据 <code>f</code> 方法的参数类型隐式转成对应的方法。</p>

<p>目前只有 <code>Statement</code> <strong>IR</strong> 需要到 <code>foreach</code>。</p>

<h4 id="statement-ir-1">Statement IR</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir -p firrtl/src/traversals
$ touch firrtl/src/traversals/Foreachers.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/traversals/Foreachers.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl.traversals</span>

<span class="k">import</span> <span class="nn">firrtl.ir._</span>
<span class="k">import</span> <span class="nn">language.implicitConversions</span>

<span class="k">object</span> <span class="nc">Foreachers</span> <span class="o">{</span>

  <span class="cm">/** Statement Foreachers */</span>
  <span class="k">private</span> <span class="k">trait</span> <span class="nc">StmtForMagnet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">object</span> <span class="nc">StmtForMagnet</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtForMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtForMagnet</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">foreachStmt</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forExp</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtForMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtForMagnet</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">foreachExpr</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtForMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtForMagnet</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">foreachType</span> <span class="n">f</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">forString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">StmtForMagnet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StmtForMagnet</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">stmt</span> <span class="n">foreachString</span> <span class="n">f</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">StmtForeach</span><span class="o">(</span><span class="k">val</span> <span class="nc">_stmt</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="c1">// Using implicit types to allow overloading of function type to foreach, see StmtForMagnet above
</span><span class="c1"></span>    <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">magnet</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span> <span class="o">=&gt;</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">StmtForMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">foreach</span><span class="o">(</span><span class="nc">_stmt</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当对一个 <code>Statement</code> 类型的 <strong>IR</strong> 进行 <code>foreach</code> 方法时（ <code>stmt foreach f</code>），实际上是根据方法 <code>f</code> 的类型不同调用的方法：</p>

<ul>
<li><code>Statement =&gt; Unit</code> 类型对应 <code>stmt foreachStmt f</code>。</li>
<li><code>Expression =&gt; Unit</code> 类型对应 <code>stmt foreachExpr f</code>。</li>
<li><code>Type =&gt; Unit</code> 类型对应 <code>stmt foreachType f</code>。</li>
<li><code>String =&gt; Unit</code> 类型对应 <code>stmt foreachStr f</code>。</li>
</ul>

<p>看下对应的这些方法，在 <code>Statement</code> <strong>IR</strong> 里是怎么定义的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Statement</span> <span class="k">extends</span> <span class="nc">FirrtlNode</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">foreachStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span>  <span class="k">:</span> <span class="kt">Unit</span>
  <span class="k">def</span> <span class="n">foreachExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Unit</span>
  <span class="k">def</span> <span class="n">foreachType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span>       <span class="k">:</span> <span class="kt">Unit</span>
  <span class="k">def</span> <span class="n">foreachString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span>   <span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>抽象类 <code>Statement</code> 规定了子类必须要有这四种方法，注意这里不管是什么方法，最后的返回值都是 <code>Unit</code> 类型。换句话说，这些方法只会以这些属性作为参数，触发相应的动作，但不会影响这些属性。</p>

<p>目前继承 <code>Statement</code> 的子类有：<code>DefNode</code>、<code>Block</code> 和 <code>Connect</code> 三种，下面分别看下它们是如何实现这些方法的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">DefNode</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Statement</span> <span class="k">with</span> <span class="nc">IsDeclaration</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">foreachStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nc">Unit</span>
  <span class="k">def</span> <span class="n">foreachExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">foreachType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nc">Unit</span>
  <span class="k">def</span> <span class="n">foreachString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>DefNode</code> 只有 <code>String</code> 和 <code>Expression</code> 两种类型的属性 <code>name</code> 和 <code>value</code>。</p>

<p>因此 <code>foreachStmt</code> 和 <code>foreachType</code> 没有匹配类型的属性，什么也不做返回空 <code>Unit</code>。</p>

<p><code>foreachExpr</code> 和 <code>foreachString</code> 方法是各自调用了函数 <code>f</code> 传入对应类型的属性 <code>f(value)</code> 和 <code>f(name)</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Block</span><span class="o">(</span><span class="n">stmts</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Statement</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Statement</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">foreachStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">stmts</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">foreachExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nc">Unit</span>
  <span class="k">def</span> <span class="n">foreachType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nc">Unit</span>
  <span class="k">def</span> <span class="n">foreachString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nc">Unit</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Block</code> 只有一个存放 <code>Statement</code> 序列的属性 <code>stmts</code>。</p>

<p>由于 <code>def foreachStmt</code> 方法的参数 <code>f</code> 是针对一个 <code>Statement</code> 的函数，要对 <code>stmts</code> 进行 <code>map</code> 迭代，一一代入每个元素作为参数执行 <code>f</code> 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Connect</span><span class="o">(</span><span class="n">loc</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">,</span> <span class="n">expr</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Statement</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">foreachStmt</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nc">Unit</span>
  <span class="k">def</span> <span class="n">foreachExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="n">loc</span><span class="o">);</span> <span class="n">f</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">def</span> <span class="n">foreachType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nc">Unit</span>
  <span class="k">def</span> <span class="n">foreachString</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nc">Unit</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>foreachExpr</code> 是会分别传入两个 <code>Expression</code> 属性：<code>loc: Expression</code> 和 <code>expr: Expression</code> 先后执行函数 <code>f</code>。</p>

<h2 id="推导类型">推导类型</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/passes/InferTypes.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/InferTypes.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl.passes</span>

<span class="k">import</span> <span class="nn">firrtl._</span>
<span class="k">import</span> <span class="nn">firrtl.ir._</span>
<span class="k">import</span> <span class="nn">firrtl.Utils._</span>
<span class="k">import</span> <span class="nn">firrtl.Mappers._</span>

<span class="k">object</span> <span class="nc">CInferTypes</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">TypeMap</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">LinkedHashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Type</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">infer_types</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">types</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TypeMap</span>
      <span class="n">m</span> <span class="n">map</span> <span class="n">infer_types_p</span><span class="o">(</span><span class="n">types</span><span class="o">)</span> <span class="n">map</span> <span class="n">infer_types_s</span><span class="o">(</span><span class="n">types</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="n">c</span> <span class="n">copy</span> <span class="o">(</span><span class="n">modules</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">modules</span> <span class="n">map</span> <span class="n">infer_types</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>c copy (modules = ...)</code> 是改变了<code>run</code> 方法的参数 <code>c: Circuit</code> 里 <code>modules</code> 属性，其他属性不变，然后作为方法的结果返回。</p>

<p>新的 <code>modules</code> 值是 <code>c.modules map infer_types</code>，这段代码把模块列表里的每个模块都调用方法 <code>infer_types</code> 来推导类型。</p>

<p><code>def infer_types</code> 方法的类型是 <code>DefModule =&gt; DefModule</code>，改变的是 <code>c: Circuit</code> 电路里的模块属性 <code>c.modules</code>。</p>

<p><code>def infer_types</code> 方法里声明了一个哈希表 <code>types: TypeMap</code>，存放名字及其对应的类型。</p>

<p><code>m map infer_types_p(types)</code> 调用 <code>infer_types_p</code> 方法改变模块 <code>port</code> 属性的类型，然后返回修改过的模块，再调用 <code>map infer_type_s(types)</code> 方法修改模块的语句列表 <code>body</code> 属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">CInferTypes</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">infer_types_p</span><span class="o">(</span><span class="n">types</span><span class="k">:</span> <span class="kt">TypeMap</span><span class="o">)(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Port</span><span class="o">)</span><span class="k">:</span> <span class="kt">Port</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">types</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">tpe</span>
      <span class="n">p</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>infer_types_p</code> 是收集已知的端口类型，按名字放入 <code>types</code> 哈希表里，并返回没有修改过的 <code>port</code> 自身。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">CInferTypes</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">infer_types_s</span><span class="o">(</span><span class="n">types</span><span class="k">:</span> <span class="kt">TypeMap</span><span class="o">)(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">sx</span><span class="k">:</span> <span class="kt">DefNode</span> <span class="o">=&gt;</span>
        <span class="k">val</span> <span class="n">sxx</span> <span class="k">=</span> <span class="o">(</span><span class="n">sx</span> <span class="n">map</span> <span class="n">infer_types_e</span><span class="o">(</span><span class="n">types</span><span class="o">)).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">DefNode</span><span class="o">]</span>
        <span class="n">types</span><span class="o">(</span><span class="n">sxx</span><span class="o">.</span><span class="n">name</span><span class="o">)</span> <span class="k">=</span> <span class="n">sxx</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">tpe</span>
        <span class="n">sxx</span>
      <span class="k">case</span> <span class="n">sx</span> <span class="k">=&gt;</span> <span class="n">sx</span> <span class="n">map</span> <span class="n">infer_types_s</span><span class="o">(</span><span class="n">types</span><span class="o">)</span> <span class="n">map</span> <span class="n">infer_types_e</span><span class="o">(</span><span class="n">types</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def infer_types_s</code> 方法是接受一个语句 <strong>IR</strong> 参数，然后返回修改过的语句 <strong>IR</strong>。一开始的时候，传入的参数是 <code>body: Statement</code>，是一个 <code>Block</code> <strong>IR</strong>，它的属性 <code>stmts</code> 是一个语句列表。所以它满足的 <code>case sx =&gt; sx ...</code> 这个条件。</p>

<p><code>sx map infer_types_s(types)</code> 会遍历 <code>body</code> 的每个语句（<code>Block(stmts map f)</code>），作为参数传入 <code>infer_types_s(types)</code> 方法里。 <code>map infer_types_e(types)</code> 对 <code>body</code> 这种 <code>Block</code> 类型的 <strong>IR</strong> 是没起什么作用的，因为它的 <code>mapExpr</code> 方法是什么也不做返回自身。</p>

<p><code>Block</code> 语句列表里还有可能是 <code>DefNode</code> 和 <code>Connect</code> 类型的<strong>IR</strong>。</p>

<p>如是 <code>DefNode</code>，符合的条件是 <code>case sx: DefNode =&gt;</code>， <code>(sx map infer_types_e(types))</code> 返回的是修改了 <code>sx</code> 之后新的值放到 <code>sxx</code>，（<code>sx</code> 本身并没有改变）。由于 <code>sx</code> 的 <code>map</code> 实际上调用的 <code>mapExpr</code> 方法返回值类型是 <code>Statement</code>，而后面的 <code>sxx.value.tpe</code> 需要的是 <code>DefNode</code> 类型（<code>DefNode</code> 才有 <code>value</code> 属性），所以需要用 <code>asInstanceOf[DefNode]</code> 转换类型。</p>

<p><code>types(sxx.name) = sxx.value.tpe</code> 是收集该 <code>DefNode</code> 的类型信息，然后返回修改过的新语句 <code>sxx</code>。</p>

<p>如果是 <code>Connect</code> <strong>IR</strong>，符合的条件是 <code>case sx =&gt; ...</code>。 <code>sx map infer_types_s(types)</code> 调用的是它的 <code>mapStmt</code> 方法，什么也不做返回自身，然后再 <code>map infer_types_e(types)</code>，调用它的 <code>mapExpr</code> 方法修改 <code>loc</code> 和 <code>expr</code> 属性。</p>

<p>接下来看下 <code>infer_types_e</code> 如何修改 <code>Expression</code> <strong>IR</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">CInferTypes</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">TypeMap</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">LinkedHashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Type</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">infer_types_e</span><span class="o">(</span><span class="n">types</span><span class="k">:</span> <span class="kt">TypeMap</span><span class="o">)(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span>
      <span class="n">e</span> <span class="n">map</span> <span class="n">infer_types_e</span><span class="o">(</span><span class="n">types</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
         <span class="k">case</span> <span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Reference</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="n">copy</span> <span class="o">(</span><span class="n">tpe</span> <span class="k">=</span> <span class="n">types</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="nc">UnknownType</span><span class="o">))</span>
         <span class="k">case</span> <span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">DoPrim</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">PrimOps</span><span class="o">.</span><span class="n">set_primop_type</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>infer_types_e</code> 方法先对参数递归调用 <code>e map infer_types_e(types)</code> 是为了保证像 <code>DoPrim</code> <strong>IR</strong> 包含了 <code>Expression</code> 的属性 <code>args: Seq[Expression]</code> 也能被修改。</p>

<p>如果是引用类型 <code>Reference</code> 的 <strong>IR</strong>，说明之前可能已经声明过了，就去收集好的类型哈希表 <code>types</code> 里面找，找不到就是未知类型了 <code>UnknownType</code>。</p>

<p>如果是运算类型 <code>DoPrim</code> 的 <strong>IR</strong>，则根据运算操作的类型和运算操作数的类型共同决定。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/PrimOps.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">firrtl.Utils.max</span>

<span class="k">object</span> <span class="nc">PrimOps</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nc">MAX</span> <span class="o">(</span><span class="n">w1</span><span class="k">:</span><span class="kt">Width</span><span class="o">,</span> <span class="n">w2</span><span class="k">:</span><span class="kt">Width</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="o">(</span><span class="n">w1</span><span class="o">,</span> <span class="n">w2</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">IntWidth</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="nc">IntWidth</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">IntWidth</span><span class="o">(</span><span class="n">max</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">MaxWidth</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">w1</span><span class="o">,</span> <span class="n">w2</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">set_primop_type</span> <span class="o">(</span><span class="n">e</span><span class="k">:</span><span class="kt">DoPrim</span><span class="o">)</span> <span class="k">:</span> <span class="kt">DoPrim</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">t1</span> <span class="k">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">tpe</span>
    <span class="k">def</span> <span class="n">t2</span> <span class="k">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">tpe</span>
    <span class="k">def</span> <span class="n">w1</span> <span class="k">=</span> <span class="n">getWidth</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">tpe</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">w2</span> <span class="k">=</span> <span class="n">getWidth</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">tpe</span><span class="o">)</span>
    <span class="n">e</span> <span class="n">copy</span> <span class="o">(</span><span class="n">tpe</span> <span class="k">=</span> <span class="n">e</span><span class="o">.</span><span class="n">op</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Not</span> <span class="k">=&gt;</span> <span class="n">t1</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">UIntType</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">UIntType</span><span class="o">(</span><span class="n">w1</span><span class="o">)</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">UnknownType</span>
      <span class="o">}</span>
      <span class="k">case</span> <span class="nc">And</span> <span class="o">|</span> <span class="nc">Or</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">UIntType</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">UIntType</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">UIntType</span><span class="o">(</span><span class="nc">MAX</span><span class="o">(</span><span class="n">w1</span><span class="o">,</span> <span class="n">w2</span><span class="o">))</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">UnknownType</span>
      <span class="o">}</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这个例子里只有 <code>Not</code>、<code>And</code>和<code>Or</code>三种运算类型。</p>

<p>如果是 <code>Not</code> 一元运算，表达式类型是操作数（只有一个）的类型。</p>

<p>如果是 <code>And</code> 和 <code>Or</code> 二元运算，表达式类型是两个操作数的类型，宽度是两者之间最大值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Utils.scala
</span><span class="c1"></span>
<span class="k">import</span> <span class="nn">firrtl.ir._</span>

<span class="k">object</span> <span class="nc">Utils</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">getWidth</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">t</span><span class="k">:</span> <span class="kt">GroundType</span> <span class="o">=&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">width</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Utils</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">s&#34;No width: </span><span class="si">$t</span><span class="s">&#34;</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="n">apply</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">tpe</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">GroundType</span> <span class="k">extends</span> <span class="nc">Type</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Width</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/LoweringCompiler.scala
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">ChirrtlToHighFirrtl</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
    <span class="n">passes</span><span class="o">.</span><span class="nc">CInferTypes</span><span class="o">,</span>
  <span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/Main.scala
</span><span class="c1"></span>
<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">val</span> <span class="n">firrtl</span> <span class="k">=</span> <span class="nc">Converter</span><span class="o">.</span><span class="n">convert</span><span class="o">(</span><span class="n">circuit</span><span class="o">)</span>

  <span class="n">println</span><span class="o">(</span><span class="s">&#34;======FIRRTL======&#34;</span><span class="o">)</span>
  <span class="n">print_fir</span><span class="o">(</span><span class="n">firrtl</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">state</span> <span class="k">=</span> <span class="nc">CircuitState</span><span class="o">(</span><span class="n">firrtl</span><span class="o">,</span> <span class="nc">ChirrtlForm</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">compiler</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VerilogCompiler</span>
  <span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">compiler</span><span class="o">.</span><span class="n">compile</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&#34;======Compiling...======&#34;</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&#34;======After Infer Types======&#34;</span><span class="o">)</span>
  <span class="n">print_fir</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">circuit</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码03</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap02-03">play-chisel/tree/chap02-03</a></p>

<h2 id="转成工作-ir">转成工作 IR</h2>

<p>工作 <strong>IR</strong> 比 <strong>IR</strong> 携带更多的信息。</p>

<p>除了上一节介绍了一些 <strong>WIR</strong> 相关的代码，还有如下的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/WIR.scala
</span><span class="c1"></span><span class="k">trait</span> <span class="nc">Kind</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">PortKind</span> <span class="k">extends</span> <span class="nc">Kind</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">NodeKind</span> <span class="k">extends</span> <span class="nc">Kind</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">UnknownKind</span> <span class="k">extends</span> <span class="nc">Kind</span>

<span class="k">trait</span> <span class="nc">Flow</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">SourceFlow</span> <span class="k">extends</span> <span class="nc">Flow</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">SinkFlow</span> <span class="k">extends</span> <span class="nc">Flow</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">UnknownFlow</span> <span class="k">extends</span> <span class="nc">Flow</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">WRef</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">kind</span><span class="k">:</span> <span class="kt">Kind</span><span class="o">,</span> <span class="n">flow</span><span class="k">:</span> <span class="kt">Flow</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">serialize</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">name</span>
  <span class="k">def</span> <span class="n">mapExpr</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span> <span class="nc">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="n">mapType</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Type</span> <span class="o">=&gt;</span> <span class="nc">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">tpe</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">tpe</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">mapWidth</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=&gt;</span> <span class="nc">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="k">this</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>WIR</strong> 多两种新的属性：类别 <strong>Kind</strong> 和 方向 <strong>Flow</strong>。</p>

<p><strong>WRef</strong> 还扩展了 <strong>Expression</strong> <strong>IR</strong>，新增了 <code>kind: Kind</code> 和 <code>flow: Flow</code> 两种新类型的属性。</p>

<p><strong>WrappedExpression</strong> 携带一个 <code>Expression</code> <strong>IR</strong> 的属性 <code>val e1</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/Passes.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">ToWorkingIR</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">toExp</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">e</span> <span class="n">map</span> <span class="n">toExp</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Reference</span> <span class="o">=&gt;</span> <span class="nc">WRef</span><span class="o">(</span><span class="n">ex</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">tpe</span><span class="o">,</span> <span class="nc">UnknownKind</span><span class="o">,</span> <span class="nc">UnknownFlow</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">ex</span> <span class="k">=&gt;</span> <span class="n">ex</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">toStmt</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">s</span> <span class="n">map</span> <span class="n">toExp</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">sx</span> <span class="k">=&gt;</span> <span class="n">sx</span> <span class="n">map</span> <span class="n">toStmt</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">run</span> <span class="o">(</span><span class="n">c</span><span class="k">:</span><span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span>
    <span class="n">c</span> <span class="n">copy</span> <span class="o">(</span><span class="n">modules</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">modules</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">toStmt</span><span class="o">))</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里只是简单地把 <code>Reference</code> 变成 <code>WRef</code> 类型，携带了额外的 <strong>Kind</strong>，和 <strong>Flow</strong> 两个属性。由于信息不够多，所以先放未知类型，留个后面的流程去解析具体的种类 <strong>Kind</strong> 和方向 <strong>Flow</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/LoweringCompiler.scala
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">IRToWorkingIR</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">passes</span><span class="o">.</span><span class="nc">ToWorkingIR</span><span class="o">)</span>
<span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/PrintIR.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">firrtl._</span>

<span class="k">object</span> <span class="nc">PrintIR</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">e_str</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">fir.Expression</span><span class="o">,</span> <span class="n">l</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
      <span class="o">...</span>
      <span class="k">case</span> <span class="nc">WRef</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&#34;WRef(</span><span class="si">${</span><span class="n">n</span><span class="si">}</span><span class="s">: </span><span class="si">${</span><span class="n">type_str</span><span class="o">(</span><span class="n">t</span><span class="o">)</span><span class="si">}</span><span class="s"> </span><span class="si">${</span><span class="n">k_str</span><span class="o">(</span><span class="n">k</span><span class="o">)</span><span class="si">}</span><span class="s"> </span><span class="si">${</span><span class="n">f_str</span><span class="o">(</span><span class="n">f</span><span class="o">)</span><span class="si">}</span><span class="s">)&#34;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">k_str</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Kind</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">k</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PortKind</span>    <span class="k">=&gt;</span> <span class="s">&#34;PortKind&#34;</span>
    <span class="k">case</span> <span class="nc">NodeKind</span>    <span class="k">=&gt;</span> <span class="s">&#34;NodeKind&#34;</span>
    <span class="k">case</span> <span class="nc">UnknownKind</span> <span class="k">=&gt;</span> <span class="s">&#34;UnknownKind&#34;</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">f_str</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Flow</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">f</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">SourceFlow</span>  <span class="k">=&gt;</span> <span class="s">&#34;SourceFlow&#34;</span>
    <span class="k">case</span> <span class="nc">SinkFlow</span>    <span class="k">=&gt;</span> <span class="s">&#34;SinkFlow&#34;</span>
    <span class="k">case</span> <span class="nc">UnknownFlow</span> <span class="k">=&gt;</span> <span class="s">&#34;UnknownFlow&#34;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码04</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap02-04">play-chisel/tree/chap02-04</a></p>

<h2 id="解析种类">解析种类</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/passes/Resolves.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/Resolves.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl.passes</span>

<span class="k">import</span> <span class="nn">firrtl._</span>
<span class="k">import</span> <span class="nn">firrtl.ir._</span>
<span class="k">import</span> <span class="nn">firrtl.Mappers._</span>

<span class="k">object</span> <span class="nc">ResolveKinds</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">KindMap</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">LinkedHashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Kind</span><span class="o">]</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">resolve_kinds</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">kinds</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KindMap</span>
    <span class="o">(</span><span class="n">m</span> <span class="n">map</span> <span class="n">find_port</span><span class="o">(</span><span class="n">kinds</span><span class="o">)</span>
       <span class="n">map</span> <span class="n">find_stmt</span><span class="o">(</span><span class="n">kinds</span><span class="o">)</span>
       <span class="n">map</span> <span class="n">resolve_stmt</span><span class="o">(</span><span class="n">kinds</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span>
    <span class="n">c</span> <span class="n">copy</span> <span class="o">(</span><span class="n">modules</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">modules</span> <span class="n">map</span> <span class="n">resolve_kinds</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里先去模块的端口和语句中寻找已知种类的信息，存到种类哈希表 <code>val kinds = new KindMap</code> 里面。最后根据这个种类哈希表来解析未知种类的语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/Resolves.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl.passes</span>

<span class="k">object</span> <span class="nc">ResolveKinds</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">find_port</span><span class="o">(</span><span class="n">kinds</span><span class="k">:</span> <span class="kt">KindMap</span><span class="o">)(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Port</span><span class="o">)</span><span class="k">:</span> <span class="kt">Port</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">kinds</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">)</span> <span class="k">=</span> <span class="nc">PortKind</span> <span class="o">;</span> <span class="n">p</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">find_stmt</span><span class="o">(</span><span class="n">kinds</span><span class="k">:</span> <span class="kt">KindMap</span><span class="o">)(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span><span class="kt">Statement</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">sx</span><span class="k">:</span> <span class="kt">DefNode</span> <span class="o">=&gt;</span> <span class="n">kinds</span><span class="o">(</span><span class="n">sx</span><span class="o">.</span><span class="n">name</span><span class="o">)</span> <span class="k">=</span> <span class="nc">NodeKind</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="o">}</span>
    <span class="n">s</span> <span class="n">map</span> <span class="n">find_stmt</span><span class="o">(</span><span class="n">kinds</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>find_port</code> 方法把端口名添加到种类哈希表里作为端口种类。</p>

<p><code>find_stmt</code> 遍历一遍语句属性，发现 <code>DefNode</code> 语句就把它添加到种类哈希表，作为 <code>NodeKind</code> 类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/Resolves.scala
</span><span class="c1"></span>
<span class="k">object</span> <span class="nc">ResolveKinds</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">resolve_expr</span><span class="o">(</span><span class="n">kinds</span><span class="k">:</span> <span class="kt">KindMap</span><span class="o">)(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">WRef</span> <span class="o">=&gt;</span> <span class="n">ex</span> <span class="n">copy</span> <span class="o">(</span><span class="n">kind</span> <span class="k">=</span> <span class="n">kinds</span><span class="o">(</span><span class="n">ex</span><span class="o">.</span><span class="n">name</span><span class="o">))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="n">map</span> <span class="n">resolve_expr</span><span class="o">(</span><span class="n">kinds</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">resolve_stmt</span><span class="o">(</span><span class="n">kinds</span><span class="k">:</span> <span class="kt">KindMap</span><span class="o">)(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span>
    <span class="n">s</span> <span class="n">map</span> <span class="n">resolve_stmt</span><span class="o">(</span><span class="n">kinds</span><span class="o">)</span> <span class="n">map</span> <span class="n">resolve_expr</span><span class="o">(</span><span class="n">kinds</span><span class="o">)</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>resolve_expr</code> 方法找到上一个步骤留下未知种类的 <code>WRef</code> <strong>IR</strong>，然后去查找种类哈希表，获得对应的种类信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/LoweringCompiler.scala
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">ResolveAndCheck</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
    <span class="n">passes</span><span class="o">.</span><span class="nc">ResolveKinds</span><span class="o">,</span>
  <span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码05</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap02-05">play-chisel/tree/chap02-05</a></p>

<h2 id="解析方向">解析方向</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/Resolves.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">ResolveFlows</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">resolve_flow</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="n">m</span> <span class="n">map</span> <span class="n">resolve_s</span>

  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span>
    <span class="n">c</span> <span class="n">copy</span> <span class="o">(</span><span class="n">modules</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">modules</span> <span class="n">map</span> <span class="n">resolve_flow</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里解析方向只针对模块的语句，不需遍历端口了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/Resolves.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">ResolveFlows</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">resolve_s</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Connect</span><span class="o">(</span><span class="n">loc</span><span class="o">,</span> <span class="n">expr</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">Connect</span><span class="o">(</span><span class="n">resolve_e</span><span class="o">(</span><span class="nc">SinkFlow</span><span class="o">)(</span><span class="n">loc</span><span class="o">),</span> <span class="n">resolve_e</span><span class="o">(</span><span class="nc">SourceFlow</span><span class="o">)(</span><span class="n">expr</span><span class="o">))</span>
    <span class="k">case</span> <span class="n">sx</span> <span class="k">=&gt;</span> <span class="n">sx</span> <span class="n">map</span> <span class="n">resolve_e</span><span class="o">(</span><span class="nc">SourceFlow</span><span class="o">)</span> <span class="n">map</span> <span class="n">resolve_s</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>如果是 <code>Connect</code> 语句，左值 <code>loc</code> 的方向是 <code>SinkFlow</code> ，右值 <code>expr</code> 的方向是 <code>SourceFlow</code>。</p>

<p>其他类型的语句是 <code>SourceFlow</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/Resolves.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">ResolveFlows</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">resolve_e</span><span class="o">(</span><span class="n">g</span><span class="k">:</span> <span class="kt">Flow</span><span class="o">)(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">WRef</span> <span class="o">=&gt;</span> <span class="n">ex</span> <span class="n">copy</span> <span class="o">(</span><span class="n">flow</span> <span class="k">=</span> <span class="n">g</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="n">map</span> <span class="n">resolve_e</span><span class="o">(</span><span class="n">g</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>resolve_e</code> 方法是设置表达式的方向为它的 <code>g: Flow</code> 参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/LoweringCompiler.scala
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">ResolveAndCheck</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
    <span class="n">passes</span><span class="o">.</span><span class="nc">ResolveKinds</span><span class="o">,</span>
    <span class="n">passes</span><span class="o">.</span><span class="nc">ResolveFlows</span><span class="o">,</span>
  <span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码06</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap02-06">play-chisel/tree/chap02-06</a></p>

<h2 id="生成-verilog">生成 Verilog</h2>

<p><code>VerilogEmitter</code> 负责生成 <strong>Verilog</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Emitter.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl</span>

<span class="k">import</span> <span class="nn">java.io.Writer</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="k">import</span> <span class="nn">firrtl.ir._</span>
<span class="k">import</span> <span class="nn">firrtl.passes._</span>
<span class="k">import</span> <span class="nn">firrtl.traversals.Foreachers._</span>
<span class="k">import</span> <span class="nn">firrtl.PrimOps._</span>
<span class="k">import</span> <span class="nn">Utils._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">EmitterException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">PassException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">VerilogEmitter</span> <span class="k">extends</span> <span class="nc">SeqTransform</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="n">emit</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">,</span> <span class="n">writer</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">circuit</span> <span class="k">=</span> <span class="n">state</span><span class="o">.</span><span class="n">circuit</span>
      <span class="n">circuit</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Module</span> <span class="o">=&gt;</span>
          <span class="k">val</span> <span class="n">renderer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VerilogRender</span><span class="o">(</span><span class="n">m</span><span class="o">)(</span><span class="n">writer</span><span class="o">)</span>
          <span class="n">renderer</span><span class="o">.</span><span class="n">emit_verilog</span><span class="o">()</span>
          <span class="n">println</span><span class="o">(</span><span class="n">writer</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="c1">// do nothing
</span><span class="c1"></span>      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">execute</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">StringWriter</span>
      <span class="n">emit</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">writer</span><span class="o">)</span>
      <span class="n">state</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>execute</code> 方法调用 <code>emit</code> 方法，传递电路状态参数和 <code>writer</code> 参数。</p>

<p><code>def emit(state: CircuitState, write: Writer)</code> 方法根据参数电路状态 <code>state</code>，把生成的 <strong>Verilog</strong> 放到参数 <code>writer</code> 里。</p>

<p>然后循环调用 <code>VerilogRender</code> 的 <code>emit_verilog</code> 方法生成电路里每个模块对应的 <strong>Verilog</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Emitter.scala
</span><span class="c1"></span><span class="k">class</span> <span class="nc">VerilogEmitter</span> <span class="k">extends</span> <span class="nc">SeqTransform</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">class</span> <span class="nc">VerilogRender</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Module</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">writer</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="n">emit_verilog</span><span class="o">()</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">build_netlist</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="n">body</span><span class="o">)</span>
      <span class="n">build_ports</span><span class="o">()</span>
      <span class="n">build_streams</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="n">body</span><span class="o">)</span>
      <span class="n">emit_streams</span><span class="o">()</span>
      <span class="n">m</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>VerilogRender</code> 类的构造器有两个参数 <code>(m: Module)</code> 和 <code>(implicit writer: Writer)</code>，<code>implicit</code> 的好处是，当类里面调用的方法需要到 <code>writer: Writer</code> 这个参数时，可以省略。</p>

<h3 id="构建网表">构建网表</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Emitter.scala
</span><span class="c1"></span><span class="k">class</span> <span class="nc">VerilogEmitter</span> <span class="k">extends</span> <span class="nc">SeqTransform</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">class</span> <span class="nc">VerilogRender</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Module</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">writer</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">netlist</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">LinkedHashMap</span><span class="o">[</span><span class="kt">WrappedExpression</span>, <span class="kt">Expression</span><span class="o">]()</span>
    <span class="k">def</span> <span class="n">build_netlist</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">s</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">build_netlist</span><span class="o">)</span>
      <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">sx</span><span class="k">:</span> <span class="kt">Connect</span> <span class="o">=&gt;</span> <span class="n">netlist</span><span class="o">(</span><span class="n">sx</span><span class="o">.</span><span class="n">loc</span><span class="o">)</span> <span class="k">=</span> <span class="n">sx</span><span class="o">.</span><span class="n">expr</span>
        <span class="k">case</span> <span class="n">sx</span><span class="k">:</span> <span class="kt">DefNode</span> <span class="o">=&gt;</span>
          <span class="k">val</span> <span class="n">e</span> <span class="k">=</span> <span class="nc">WRef</span><span class="o">(</span><span class="n">sx</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">sx</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">tpe</span><span class="o">,</span> <span class="nc">NodeKind</span><span class="o">,</span> <span class="nc">SourceFlow</span><span class="o">)</span>
          <span class="n">netlist</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=</span> <span class="n">sx</span><span class="o">.</span><span class="n">value</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>netlist</code> 存的是 <code>WrappedExpression</code> 为键， <code>Expression</code> 为值的哈希表。</p>

<p>如果是 <code>Connect</code> 语句，则赋值语句的左值 <code>sx.loc</code> 为键，右值 <code>sx.expr</code> 为值。</p>

<p>如果是 <code>DefNode</code> 语句，键是 <code>WRef</code>，值是 <code>DefNode</code> 的值 <code>sx.value</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Emitter.scala
</span><span class="c1"></span><span class="k">class</span> <span class="nc">VerilogEmitter</span> <span class="k">extends</span> <span class="nc">SeqTransform</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">class</span> <span class="nc">VerilogRender</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Module</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">writer</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">val</span> <span class="n">portdefs</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]()</span>
    <span class="k">val</span> <span class="n">declares</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]()</span>
    <span class="k">val</span> <span class="n">assigns</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]()</span>
    <span class="k">def</span> <span class="n">declare</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">tx</span> <span class="k">=&gt;</span>
        <span class="n">declares</span> <span class="o">+=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">tx</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span><span class="s">&#34;;&#34;</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">assign</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">assigns</span> <span class="o">+=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;assign &#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="s">&#34; = &#34;</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="s">&#34;;&#34;</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>portdefs</code>、<code>declares</code> 和 <code>assigns</code> 分别用于存放端口定义，声明和赋值语句。</p>

<p><code>def declare</code> 和 <code>def assign</code> 方法分别往各自的数组里添加信息。</p>

<h3 id="构建端口">构建端口</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Emitter.scala
</span><span class="c1"></span><span class="k">class</span> <span class="nc">VerilogEmitter</span> <span class="k">extends</span> <span class="nc">SeqTransform</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">class</span> <span class="nc">VerilogRender</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Module</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">writer</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="c1">// Turn ports into Seq[String] and add to portdefs
</span><span class="c1"></span>    <span class="k">def</span> <span class="n">build_ports</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">padToMax</span><span class="o">(</span><span class="n">strs</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">len</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">strs</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span> <span class="n">strs</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">).</span><span class="n">max</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">strs</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">padTo</span><span class="o">(</span><span class="n">len</span><span class="o">,</span> <span class="sc">&#39; &#39;</span><span class="o">))</span>
      <span class="o">}</span>

      <span class="c1">// Turn directions into strings (and AnalogType into inout)
</span><span class="c1"></span>      <span class="k">val</span> <span class="n">dirs</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ports</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Port</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">dir</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="o">(</span><span class="nc">Input</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&#34;input &#34;</span>
          <span class="k">case</span> <span class="o">(</span><span class="nc">Output</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&#34;output&#34;</span>
        <span class="o">}</span>
      <span class="o">}</span>
      <span class="c1">// Turn types into strings, all ports must be GroundTypes
</span><span class="c1"></span>      <span class="k">val</span> <span class="n">tpes</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ports</span> <span class="n">map</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Port</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">GroundType</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">stringify</span><span class="o">(</span><span class="n">tpe</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Port</span> <span class="o">=&gt;</span> <span class="n">error</span><span class="o">(</span><span class="s">s&#34;Trying to emit non-GroundType Port </span><span class="si">$port</span><span class="s">&#34;</span><span class="o">)</span>
      <span class="o">}</span>

      <span class="c1">// dirs are already padded
</span><span class="c1"></span>      <span class="o">(</span><span class="n">dirs</span><span class="o">,</span> <span class="n">padToMax</span><span class="o">(</span><span class="n">tpes</span><span class="o">),</span> <span class="n">m</span><span class="o">.</span><span class="n">ports</span><span class="o">).</span><span class="n">zipped</span><span class="o">.</span><span class="n">toSeq</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">((</span><span class="n">dir</span><span class="o">,</span> <span class="n">tpe</span><span class="o">,</span> <span class="nc">Port</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)),</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">m</span><span class="o">.</span><span class="n">ports</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">portdefs</span> <span class="o">+=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">tpe</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="s">&#34;,&#34;</span><span class="o">)</span>
          <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">portdefs</span> <span class="o">+=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">tpe</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span>
          <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">padToMax</span><span class="o">(</span><span class="n">strs</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">len</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">strs</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span> <span class="n">strs</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">).</span><span class="n">max</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">strs</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">padTo</span><span class="o">(</span><span class="n">len</span><span class="o">,</span> <span class="sc">&#39; &#39;</span><span class="o">))</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>先获取整个数组字符串中最大的长度，然后为每个字符串拼接空格达到最大的长度，用作对齐。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Turn directions into strings (and AnalogType into inout)
</span><span class="c1"></span><span class="k">val</span> <span class="n">dirs</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ports</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Port</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">dir</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="n">tpe</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Input</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&#34;input &#34;</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Output</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&#34;output&#34;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>获取每个端口的方向，输入为 <code>&quot;input&quot;</code>，输出为 <code>&quot;output&quot;</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Turn types into strings, all ports must be GroundTypes
</span><span class="c1"></span><span class="k">val</span> <span class="n">tpes</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ports</span> <span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Port</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">GroundType</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">stringify</span><span class="o">(</span><span class="n">tpe</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Port</span> <span class="o">=&gt;</span> <span class="n">error</span><span class="o">(</span><span class="s">s&#34;Trying to emit non-GroundType Port </span><span class="si">$port</span><span class="s">&#34;</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>获取每个端口类型对应的字符串。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// dirs are already padded
</span><span class="c1"></span><span class="o">(</span><span class="n">dirs</span><span class="o">,</span> <span class="n">padToMax</span><span class="o">(</span><span class="n">tpes</span><span class="o">),</span> <span class="n">m</span><span class="o">.</span><span class="n">ports</span><span class="o">).</span><span class="n">zipped</span><span class="o">.</span><span class="n">toSeq</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">((</span><span class="n">dir</span><span class="o">,</span> <span class="n">tpe</span><span class="o">,</span> <span class="nc">Port</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)),</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">m</span><span class="o">.</span><span class="n">ports</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">portdefs</span> <span class="o">+=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">tpe</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="s">&#34;,&#34;</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">portdefs</span> <span class="o">+=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">tpe</span><span class="o">,</span> <span class="s">&#34; &#34;</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>开始生成端口的 <strong>Verilog</strong> 定义，最后一个端口定义的结尾没有逗号 <code>,</code>。</p>

<h3 id="构建语句">构建语句</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">build_streams</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">s</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">build_streams</span><span class="o">)</span>
  <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">sx</span><span class="nd">@Connect</span><span class="o">(</span><span class="n">loc</span><span class="nd">@WRef</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="nc">PortKind</span><span class="o">,</span> <span class="k">_</span><span class="o">),</span> <span class="n">expr</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">assign</span><span class="o">(</span><span class="n">loc</span><span class="o">,</span> <span class="n">expr</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">sx</span><span class="k">:</span> <span class="kt">DefNode</span> <span class="o">=&gt;</span>
      <span class="n">declare</span><span class="o">(</span><span class="s">&#34;wire&#34;</span><span class="o">,</span> <span class="n">sx</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">sx</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">tpe</span><span class="o">)</span>
      <span class="n">assign</span><span class="o">(</span><span class="nc">WRef</span><span class="o">(</span><span class="n">sx</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">sx</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">tpe</span><span class="o">,</span> <span class="nc">NodeKind</span><span class="o">,</span> <span class="nc">SourceFlow</span><span class="o">),</span> <span class="n">sx</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>s.foreach(build_streams)</code> 先确保内嵌语句列表的 <strong>Statement</strong>（比如 <code>Block</code>）也能被方法 <code>build_streams</code> 遍历到。</p>

<p>如果是 <code>Connect</code> 语句，直接把左值和右值添加到赋值语句列表。</p>

<p>如果是 <code>DefNode</code> 语句，先添加到声明语句列表，然后再添加到赋值语句列表。</p>

<h3 id="生成语句">生成语句</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">emit_streams</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">emit</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;module &#34;</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="s">&#34;(&#34;</span><span class="o">))</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">portdefs</span><span class="o">)</span> <span class="n">emit</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
  <span class="n">emit</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;);&#34;</span><span class="o">))</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">declares</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">&amp;&amp;</span> <span class="n">assigns</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">emit</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="s">&#34;initial begin end&#34;</span><span class="o">))</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">declares</span><span class="o">)</span> <span class="n">emit</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">assigns</span><span class="o">)</span> <span class="n">emit</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
  <span class="n">emit</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;endmodule&#34;</span><span class="o">))</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里是真正生成 <strong>Verilog</strong> 语句的方法，先声明模块名字，然后是端口列表，声明语句和赋值语句，最后是模块的结束。</p>

<h3 id="辅助方法">辅助方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">tab</span> <span class="k">=</span> <span class="s">&#34;  &#34;</span>
<span class="k">def</span> <span class="n">stringify</span><span class="o">(</span><span class="n">tpe</span><span class="k">:</span> <span class="kt">GroundType</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">tpe</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">UIntType</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">wx</span> <span class="k">=</span> <span class="n">bitWidth</span><span class="o">(</span><span class="n">tpe</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">wx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="s">s&#34;[</span><span class="si">$wx</span><span class="s">:0]&#34;</span> <span class="k">else</span> <span class="s">&#34;&#34;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">throwInternalError</span><span class="o">(</span><span class="s">s&#34;trying to write unsupported type in the Verilog Emitter: </span><span class="si">$tpe</span><span class="s">&#34;</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">def</span> <span class="n">emit</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">w</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="n">emit</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">}</span>
<span class="k">def</span> <span class="n">emit</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">top</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">w</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cast</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">tpe</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">UIntType</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">throwInternalError</span><span class="o">(</span><span class="s">s&#34;unrecognized cast: </span><span class="si">$e</span><span class="s">&#34;</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">DoPrim</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">emit</span><span class="o">(</span><span class="n">op_stream</span><span class="o">(</span><span class="n">e</span><span class="o">),</span> <span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">WRef</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="n">write</span> <span class="n">e</span><span class="o">.</span><span class="n">serialize</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">GroundType</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="n">write</span> <span class="n">stringify</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="n">write</span> <span class="n">s</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="n">write</span> <span class="n">i</span><span class="o">.</span><span class="n">toString</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="n">write</span> <span class="n">i</span><span class="o">.</span><span class="n">toString</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="n">write</span> <span class="n">i</span><span class="o">.</span><span class="n">toString</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span> <span class="k">=&gt;</span>
      <span class="n">s</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">emit</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">top</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">w</span> <span class="n">write</span> <span class="s">&#34;\n&#34;</span>
    <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">throwInternalError</span><span class="o">(</span><span class="s">s&#34;trying to emit unsupported operator: </span><span class="si">$x</span><span class="s">&#34;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">op_stream</span><span class="o">(</span><span class="n">doprim</span><span class="k">:</span> <span class="kt">DoPrim</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cast_as</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">tpe</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">UIntType</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">throwInternalError</span><span class="o">(</span><span class="s">s&#34;cast_as - unrecognized type: </span><span class="si">$e</span><span class="s">&#34;</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">a0</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">doprim</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">head</span>
  <span class="k">def</span> <span class="n">a1</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">doprim</span><span class="o">.</span><span class="n">args</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">checkArgumentLegality</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">WRef</span> <span class="o">=&gt;</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="nc">EmitterException</span><span class="o">(</span><span class="s">s&#34;Can&#39;t emit </span><span class="si">${</span><span class="n">e</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span><span class="si">}</span><span class="s"> as PrimOp argument&#34;</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">doprim</span><span class="o">.</span><span class="n">args</span> <span class="n">foreach</span> <span class="n">checkArgumentLegality</span>
  <span class="n">doprim</span><span class="o">.</span><span class="n">op</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Not</span> <span class="k">=&gt;</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;~ &#34;</span><span class="o">,</span> <span class="n">a0</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">And</span> <span class="k">=&gt;</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">cast_as</span><span class="o">(</span><span class="n">a0</span><span class="o">),</span> <span class="s">&#34; &amp; &#34;</span><span class="o">,</span> <span class="n">cast_as</span><span class="o">(</span><span class="n">a1</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Or</span> <span class="k">=&gt;</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">cast_as</span><span class="o">(</span><span class="n">a0</span><span class="o">),</span> <span class="s">&#34; | &#34;</span><span class="o">,</span> <span class="n">cast_as</span><span class="o">(</span><span class="n">a1</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>stringify</code> 方法是把类型转成对应的字符串。</p>

<p><code>emit</code> 生成最终的 <strong>Verilog</strong> 字符串，写入 <code>Writer</code>。</p>

<p><code>op_stream</code> 根据运算语句生成对应的 <strong>Verilog</strong> 语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/WIR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">WRef</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">tpe</span><span class="k">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">kind</span><span class="k">:</span> <span class="kt">Kind</span><span class="o">,</span> <span class="n">flow</span><span class="k">:</span> <span class="kt">Flow</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">serialize</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">name</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">WrappedExpression</span><span class="o">(</span><span class="k">val</span> <span class="n">e1</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Utils.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">language.implicitConversions</span>

<span class="k">object</span> <span class="nc">Utils</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">toWrappedExpression</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedExpression</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WrappedExpression</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">bitWidth</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">dt</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="n">widthOf</span><span class="o">(</span><span class="n">dt</span><span class="o">)</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">widthOf</span><span class="o">(</span><span class="n">dt</span><span class="k">:</span> <span class="kt">Type</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="n">dt</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">GroundType</span><span class="o">(</span><span class="nc">IntWidth</span><span class="o">(</span><span class="n">width</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">width</span>
    <span class="k">case</span> <span class="n">t</span> <span class="k">=&gt;</span> <span class="nc">Utils</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">s&#34;Unknown type encountered in bitWidth: </span><span class="si">$dt</span><span class="s">&#34;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/Passes.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl.passes</span>

<span class="k">class</span> <span class="nc">PassException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">FirrtlUserException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/FirrtlException.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">scala.util.control.NoStackTrace</span>

<span class="k">class</span> <span class="nc">FirrtlUserException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">cause</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="n">message</span><span class="o">,</span> <span class="n">cause</span><span class="o">)</span> <span class="k">with</span> <span class="nc">NoStackTrace</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/ir/IR.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">GroundType</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">ground</span><span class="k">:</span> <span class="kt">GroundType</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Width</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ground</span><span class="o">.</span><span class="n">width</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>删掉之前打印的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/Main.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">val</span> <span class="n">firrtl</span> <span class="k">=</span> <span class="nc">Converter</span><span class="o">.</span><span class="n">convert</span><span class="o">(</span><span class="n">circuit</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">state</span> <span class="k">=</span> <span class="nc">CircuitState</span><span class="o">(</span><span class="n">firrtl</span><span class="o">,</span> <span class="nc">ChirrtlForm</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">compiler</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VerilogCompiler</span>
  <span class="n">compiler</span><span class="o">.</span><span class="n">compile</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码07</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap02-07">play-chisel/tree/chap02-07</a></p>

<h2 id="增加转换过程的详细信息">增加转换过程的详细信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/Compiler.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">debug.PrintIR._</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">SeqTransform</span> <span class="k">extends</span> <span class="nc">Transform</span> <span class="k">with</span> <span class="nc">SeqTransformBased</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">execute</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">CircuitState</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitState</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ret</span> <span class="k">=</span> <span class="n">runTransforms</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;======After </span><span class="si">${</span><span class="k">this</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getSimpleName</span><span class="si">}</span><span class="s">======&#34;</span><span class="o">)</span>
      <span class="n">print_fir</span><span class="o">(</span><span class="n">ret</span><span class="o">.</span><span class="n">circuit</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&#34;===================&#34;</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="nc">CircuitState</span><span class="o">(</span><span class="n">ret</span><span class="o">.</span><span class="n">circuit</span><span class="o">,</span> <span class="n">outputForm</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>删掉 <code>src/Main.scala</code> 里的 <code>import PrintIR._</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mv src/PrintIR.scala firrtl/src/PrintIR.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/PrintIR.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">debug</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码08</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap02-08">play-chisel/tree/chap02-08</a></p>

<h1 id="自定义">自定义</h1>

<p><strong>Chisel</strong> 默认生成的 <strong>Verilog</strong> 可能不符合想要的代码风格，自定义这章讲一些如何自定义生成的 <strong>Verilog</strong>。</p>

<h2 id="合并冗余的节点">合并冗余的节点</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">io</span><span class="o">.</span><span class="n">out</span> <span class="k">:</span><span class="o">=</span> <span class="o">(</span><span class="n">io</span><span class="o">.</span><span class="n">sel</span> <span class="o">&amp;</span> <span class="n">io</span><span class="o">.</span><span class="n">in1</span><span class="o">)</span> <span class="o">|</span> <span class="o">(~</span><span class="n">io</span><span class="o">.</span><span class="n">sel</span> <span class="o">&amp;</span> <span class="n">io</span><span class="o">.</span><span class="n">in0</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<p>会生成带中间变量的形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></pre></td>
<td class="lntd">
<pre class="chroma">node _T = and(sel, in1)
node _T_1 = not(sel)
node _T_2 = and(_T_1, in0)
node _T_3 = or(_T, _T_2)
out &lt;= _T_3</pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="kt">wire</span>  <span class="n">_T</span><span class="p">;</span>
<span class="kt">wire</span>  <span class="n">_T_1</span><span class="p">;</span>
<span class="kt">wire</span>  <span class="n">_T_2</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">_T</span> <span class="o">=</span> <span class="n">sel</span> <span class="o">&amp;</span> <span class="n">in1</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">_T_1</span> <span class="o">=</span> <span class="o">~</span> <span class="n">sel</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">_T_2</span> <span class="o">=</span> <span class="n">_T_1</span> <span class="o">&amp;</span> <span class="n">in0</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">out</span> <span class="o">=</span> <span class="n">_T</span> <span class="o">|</span> <span class="n">_T_2</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div>
<p>这种生成的代码很不直观，希望生成没有中间节点的形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">assign</span> <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">sel</span> <span class="o">&amp;</span> <span class="n">in1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="o">~</span> <span class="n">sel</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">in0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
<p>新建一个合并冗余节点的 <code>Pass</code>。</p>

<p>先收集每个中间节点对应的表达式，存到 ~HashMap~ 里；然后把中间节点都替换成对应的表达式；最后删掉中间节点的声明语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch firrtl/src/passes/MergeNodes.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/passes/MergeNodes.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">firrtl.passes</span>

<span class="k">import</span> <span class="nn">firrtl._</span>
<span class="k">import</span> <span class="nn">firrtl.ir._</span>
<span class="k">import</span> <span class="nn">firrtl.Mappers._</span>

<span class="k">object</span> <span class="nc">MergeNodes</span> <span class="k">extends</span> <span class="nc">Pass</span> <span class="o">{</span>
  <span class="c1">// 新建空的 HashMap
</span><span class="c1"></span>  <span class="k">type</span> <span class="kt">RefMap</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">LinkedHashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Expression</span><span class="o">]</span>

  <span class="c1">// 解析表达式，如果是节点类型的引用，去 HashMap 里找到对应表达式
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">resolve_e</span><span class="o">(</span><span class="n">refs</span><span class="k">:</span> <span class="kt">RefMap</span><span class="o">)(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">WRef</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">kind</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="nc">NodeKind</span> <span class="k">=&gt;</span> <span class="n">refs</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="n">map</span> <span class="n">resolve_e</span><span class="o">(</span><span class="n">refs</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// 解析语句，如果是节点定义的语句，把节点名字和表达式记录下来
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">resolve_s</span><span class="o">(</span><span class="n">refs</span><span class="k">:</span> <span class="kt">RefMap</span><span class="o">)(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">d</span><span class="nd">@DefNode</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">d</span> <span class="n">map</span> <span class="n">resolve_e</span><span class="o">(</span><span class="n">refs</span><span class="o">)</span> <span class="n">map</span> <span class="n">resolve_s</span><span class="o">(</span><span class="n">refs</span><span class="o">)</span>
      <span class="n">res</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">DefNode</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">refs</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="k">=</span> <span class="n">v</span>
      <span class="o">}</span>
      <span class="n">res</span>
    <span class="k">case</span> <span class="n">sx</span> <span class="k">=&gt;</span>
      <span class="n">sx</span> <span class="n">map</span> <span class="n">resolve_e</span><span class="o">(</span><span class="n">refs</span><span class="o">)</span> <span class="n">map</span> <span class="n">resolve_s</span><span class="o">(</span><span class="n">refs</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">merge_nodes</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">refs</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RefMap</span>
    <span class="n">m</span> <span class="n">map</span> <span class="n">resolve_s</span><span class="o">(</span><span class="n">refs</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// 过滤语句列表，去掉定义节点的语句
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">remove_s</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Statement</span><span class="o">)</span><span class="k">:</span> <span class="kt">Statement</span> <span class="o">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">b</span><span class="nd">@Block</span><span class="o">(</span><span class="n">stmts</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">stmts</span> <span class="k">=</span> <span class="n">stmts</span> <span class="n">filter</span> <span class="o">{</span>
               <span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
                 <span class="k">case</span> <span class="k">_:</span> <span class="kt">DefNode</span> <span class="o">=&gt;</span> <span class="kc">false</span>
                 <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">true</span>
               <span class="o">}})</span> <span class="n">map</span> <span class="n">remove_s</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">s</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">remove_nodes</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">DefModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">m</span> <span class="n">map</span> <span class="n">remove_s</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Circuit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">c</span> <span class="n">copy</span> <span class="o">(</span><span class="n">modules</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">modules</span> <span class="n">map</span> <span class="n">merge_nodes</span><span class="o">)</span>
    <span class="n">res</span> <span class="n">copy</span> <span class="o">(</span><span class="n">modules</span> <span class="k">=</span> <span class="n">res</span><span class="o">.</span><span class="n">modules</span> <span class="n">map</span> <span class="n">remove_nodes</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在 <strong>LowFirrtlOptimization</strong> 阶段加入合并冗余节点的 <strong>Pass</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/firrtl/src/LoweringCompiler.scala
</span><span class="c1"></span><span class="k">class</span> <span class="nc">LowFirrtlOptimization</span> <span class="k">extends</span> <span class="nc">CoreTransform</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">transforms</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
    <span class="n">passes</span><span class="o">.</span><span class="nc">MergeNodes</span><span class="o">,</span>
  <span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>修改下生成运算操作的参数。 ~checkArgumentLegality~ 检查参数的合法性新增了表达式类型（即中间节点对应的表达式），之前只能是一个引用（WRef，即中间节点的名字）。判断是不是同一个运算操作类型，用于是否需要加括号确保运算的优先级。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">op_stream</span><span class="o">(</span><span class="n">doprim</span><span class="k">:</span> <span class="kt">DoPrim</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">is_same_op</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">d</span><span class="k">:</span> <span class="kt">DoPrim</span> <span class="kt">if</span> <span class="o">(</span><span class="kt">d.op</span> <span class="kt">!=</span> <span class="kt">doprim.op</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="kc">false</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">checkArgumentLegality</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">WRef</span> <span class="kt">|</span> <span class="k">_</span><span class="kt">:</span> <span class="kt">Expression</span> <span class="o">=&gt;</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="nc">EmitterException</span><span class="o">(</span><span class="s">s&#34;Can&#39;t emit </span><span class="si">${</span><span class="n">e</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span><span class="si">}</span><span class="s"> as PrimOp argument&#34;</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">doprim</span><span class="o">.</span><span class="n">op</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Not</span> <span class="k">=&gt;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">is_same_op</span><span class="o">(</span><span class="n">a0</span><span class="o">))</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;~ &#34;</span><span class="o">,</span> <span class="n">a0</span><span class="o">)</span>
      <span class="k">else</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;~ &#34;</span><span class="o">,</span> <span class="s">&#34;(&#34;</span><span class="o">,</span> <span class="n">a0</span><span class="o">,</span> <span class="s">&#34;)&#34;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">And</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">a0_seq</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">is_same_op</span><span class="o">(</span><span class="n">a0</span><span class="o">))</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">cast_as</span><span class="o">(</span><span class="n">a0</span><span class="o">))</span> <span class="k">else</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;(&#34;</span><span class="o">,</span> <span class="n">cast_as</span><span class="o">(</span><span class="n">a0</span><span class="o">),</span> <span class="s">&#34;)&#34;</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">a1_seq</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">is_same_op</span><span class="o">(</span><span class="n">a1</span><span class="o">))</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">cast_as</span><span class="o">(</span><span class="n">a1</span><span class="o">))</span> <span class="k">else</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;(&#34;</span><span class="o">,</span> <span class="n">cast_as</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="s">&#34;)&#34;</span><span class="o">)</span>
      <span class="n">a0_seq</span> <span class="o">++</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34; &amp; &#34;</span><span class="o">)</span> <span class="o">++</span> <span class="n">a1_seq</span>
    <span class="k">case</span> <span class="nc">Or</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">a0_seq</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">is_same_op</span><span class="o">(</span><span class="n">a0</span><span class="o">))</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">cast_as</span><span class="o">(</span><span class="n">a0</span><span class="o">))</span> <span class="k">else</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;(&#34;</span><span class="o">,</span> <span class="n">cast_as</span><span class="o">(</span><span class="n">a0</span><span class="o">),</span> <span class="s">&#34;)&#34;</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">a1_seq</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">is_same_op</span><span class="o">(</span><span class="n">a1</span><span class="o">))</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">cast_as</span><span class="o">(</span><span class="n">a1</span><span class="o">))</span> <span class="k">else</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34;(&#34;</span><span class="o">,</span> <span class="n">cast_as</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="s">&#34;)&#34;</span><span class="o">)</span>
      <span class="n">a0_seq</span> <span class="o">++</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&#34; | &#34;</span><span class="o">)</span> <span class="o">++</span> <span class="n">a1_seq</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/custom-01">play-chisel/tree/custom-01</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">咧威</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-12-17
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/build-chisel-from-scratch/post/getting-started/">
            <span class="next-text nav-default">第一章 开始构建 Chisel</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:colin4124@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/colin4124" class="iconfont icon-github" title="github"></a>
  <a href="http://funwo.ml/build-chisel-from-scratch/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">咧威</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="http://funwo.ml/build-chisel-from-scratch/js/feather.min.js"></script>
<script>
 feather.replace()
</script>


  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/build-chisel-from-scratch/dist/even.26188efa.min.js"></script>








</body>
</html>
