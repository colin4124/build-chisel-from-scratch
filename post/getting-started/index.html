<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>第一章 开始构建 Chisel - 从零构建 Chisel</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="本章从一个最简单的多路选择器入手，讲解如何用 Mill 搭建项目的构建环境，开发满足生成多路选择器模块的 Chisel 基本框架。" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.59.1 with theme even" />


<link rel="canonical" href="http://funwo.ml/build-chisel-from-scratch/post/getting-started/" />
<link rel="apple-touch-icon" sizes="180x180" href="/build-chisel-from-scratch/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/build-chisel-from-scratch/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/build-chisel-from-scratch/favicon-16x16.png">
<link rel="manifest" href="/build-chisel-from-scratch/manifest.json">
<link rel="mask-icon" href="/build-chisel-from-scratch/safari-pinned-tab.svg" color="#5bbad5">


<link href="/build-chisel-from-scratch/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="第一章 开始构建 Chisel" />
<meta property="og:description" content="本章从一个最简单的多路选择器入手，讲解如何用 Mill 搭建项目的构建环境，开发满足生成多路选择器模块的 Chisel 基本框架。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://funwo.ml/build-chisel-from-scratch/post/getting-started/" />
<meta property="article:published_time" content="2019-11-30T16:14:50+08:00" />
<meta property="article:modified_time" content="2019-11-30T16:14:50+08:00" /><meta property="og:site_name" content="从零构建 Chisel" />
<meta itemprop="name" content="第一章 开始构建 Chisel">
<meta itemprop="description" content="本章从一个最简单的多路选择器入手，讲解如何用 Mill 搭建项目的构建环境，开发满足生成多路选择器模块的 Chisel 基本框架。">


<meta itemprop="datePublished" content="2019-11-30T16:14:50&#43;08:00" />
<meta itemprop="dateModified" content="2019-11-30T16:14:50&#43;08:00" />
<meta itemprop="wordCount" content="14509">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="第一章 开始构建 Chisel"/>
<meta name="twitter:description" content="本章从一个最简单的多路选择器入手，讲解如何用 Mill 搭建项目的构建环境，开发满足生成多路选择器模块的 Chisel 基本框架。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/build-chisel-from-scratch/" class="logo">从零构建 Chisel</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/build-chisel-from-scratch/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/build-chisel-from-scratch/post/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/build-chisel-from-scratch/" class="logo">从零构建 Chisel</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/build-chisel-from-scratch/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/build-chisel-from-scratch/post/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">第一章 开始构建 Chisel</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-11-30 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#目标">目标</a></li>
<li><a href="#mill-环境搭建">Mill 环境搭建</a></li>
<li><a href="#搭建基本的-chisel-框架">搭建基本的 Chisel 框架</a>
<ul>
<li><a href="#main-scala">Main.scala</a></li>
<li><a href="#builder">Builder</a></li>
<li><a href="#module">Module</a></li>
<li><a href="#rawmodule">RawModule</a></li>
<li><a href="#ir">IR</a></li>
<li><a href="#data-scala">Data.scala</a></li>
<li><a href="#element-scala">Element.scala</a></li>
<li><a href="#num-scala">Num.scala</a></li>
<li><a href="#bits-scala">Bits.scala</a></li>
<li><a href="#uintfactory-scala">UIntFactory.scala</a></li>
<li><a href="#package-scala">package.scala</a></li>
<li><a href="#emitter-scala">Emitter.scala</a></li>
</ul></li>
<li><a href="#自底向上继续完善-chisel">自底向上继续完善 Chisel</a>
<ul>
<li><a href="#io-绑定">IO 绑定</a>
<ul>
<li><a href="#当前模块">当前模块</a></li>
<li><a href="#模块的关闭状态">模块的关闭状态</a></li>
<li><a href="#chiseltype-hardwaretype">ChiselType &amp; HardwareType</a></li>
<li><a href="#绑定的类型-binding">绑定的类型 Binding</a></li>
<li><a href="#复制方法-clonetypefull">复制方法 cloneTypeFull</a></li>
<li><a href="#绑定io端口">绑定IO端口</a></li>
</ul></li>
<li><a href="#input-output">Input/Output</a></li>
<li><a href="#command-命令">Command 命令</a>
<ul>
<li><a href="#位运算">位运算</a></li>
<li><a href="#connect-命令">Connect 命令</a></li>
</ul></li>
<li><a href="#命名空间">命名空间</a></li>
<li><a href="#生成-verilog-模块">生成 Verilog 模块</a></li>
<li><a href="#生成电路-ir">生成电路 IR</a></li>
</ul></li>
<li><a href="#解析-ir-生成-firrtl">解析 IR 生成 FIRRTL</a></li>
<li><a href="#生成-verilog">生成 Verilog</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>本章从一个最简单的多路选择器入手，讲解如何用 Mill 搭建项目的构建环境，开发满足生成多路选择器模块的 Chisel 基本框架。</p>

<h1 id="目标">目标</h1>

<p>二选一的多路选择器用 <strong>Chisel</strong> 来写，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Mux2</span> <span class="k">extends</span> <span class="nc">RawModule</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">sel</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">1.</span><span class="n">W</span><span class="o">)))</span>
  <span class="k">val</span> <span class="n">in0</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">1.</span><span class="n">W</span><span class="o">)))</span>
  <span class="k">val</span> <span class="n">in1</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">1.</span><span class="n">W</span><span class="o">)))</span>
  <span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Output</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">1.</span><span class="n">W</span><span class="o">)))</span>
  <span class="n">io</span><span class="o">.</span><span class="n">out</span> <span class="k">:</span><span class="o">=</span> <span class="o">(</span><span class="n">io</span><span class="o">.</span><span class="n">sel</span> <span class="o">&amp;</span> <span class="n">io</span><span class="o">.</span><span class="n">in1</span><span class="o">)</span> <span class="o">|</span> <span class="o">(~</span><span class="n">io</span><span class="o">.</span><span class="n">sel</span> <span class="o">&amp;</span> <span class="n">io</span><span class="o">.</span><span class="n">in0</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这章的目标就是生成如下的 <strong>FIRRTL</strong> <code>Mux2.fir</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-firrtl" data-lang="firrtl"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-firrtl" data-lang="firrtl">circuit Mux2 :
  module Mux2 :
    input sel : UInt&lt;1&gt;
    input in0 : UInt&lt;1&gt;
    input in1 : UInt&lt;1&gt;
    output out : UInt&lt;1&gt;

    node _T = and(sel, in1)
    node _T_1 = not(sel)
    node _T_2 = and(_T_1, in0)
    node _T_3 = or(_T, _T_2)
    out &lt;= _T_3</code></pre></td></tr></table>
</div>
</div>
<p>最后再用 <strong>FIRRTL</strong> 生成如下的 <strong>Verilog</strong> <code>Mux2.v</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">Mux2</span><span class="p">(</span>
  <span class="k">input</span>   <span class="n">sel</span><span class="p">,</span>
  <span class="k">input</span>   <span class="n">in0</span><span class="p">,</span>
  <span class="k">input</span>   <span class="n">in1</span><span class="p">,</span>
  <span class="k">output</span>  <span class="n">out</span>
<span class="p">);</span>
  <span class="kt">wire</span>  <span class="n">_T</span><span class="p">;</span>
  <span class="kt">wire</span>  <span class="n">_T_1</span><span class="p">;</span>
  <span class="kt">wire</span>  <span class="n">_T_2</span><span class="p">;</span>
  <span class="k">assign</span> <span class="n">_T</span> <span class="o">=</span> <span class="n">sel</span> <span class="o">&amp;</span> <span class="n">in1</span><span class="p">;</span>
  <span class="k">assign</span> <span class="n">_T_1</span> <span class="o">=</span> <span class="o">~</span> <span class="n">sel</span><span class="p">;</span>
  <span class="k">assign</span> <span class="n">_T_2</span> <span class="o">=</span> <span class="n">_T_1</span> <span class="o">&amp;</span> <span class="n">in0</span><span class="p">;</span>
  <span class="k">assign</span> <span class="n">out</span> <span class="o">=</span> <span class="n">_T</span> <span class="o">|</span> <span class="n">_T_2</span><span class="p">;</span>
<span class="k">endmodule</span>
</code></pre></td></tr></table>
</div>
</div>
<h1 id="mill-环境搭建">Mill 环境搭建</h1>

<p><a href="http://www.lihaoyi.com/mill/">Mill 的安装方式</a></p>

<p>新建文件夹 <code>play-chisel</code> ，定义 <code>build.sc</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir play-chisel
$ <span class="nb">cd</span> play-chisel
$ touch build.sc</code></pre></td></tr></table>
</div>
</div>
<p>为了更清楚地表示路径，都会加上 <code>play-chisel</code> 来表示项目里的绝对路径，并在每个文件的顶部加上绝对路径的注释。</p>

<p>例如，<code>build.sc</code> 的绝对路径是 <code>play-chisel/build.sc</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/build.sc
</span><span class="c1"></span><span class="k">import</span> <span class="nn">ammonite.ops._</span>
<span class="k">import</span> <span class="nn">mill._</span>
<span class="k">import</span> <span class="nn">mill.scalalib._</span>

<span class="k">trait</span> <span class="nc">CommonChiselModule</span> <span class="k">extends</span> <span class="nc">ScalaModule</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">scalaVersion</span> <span class="k">=</span> <span class="s">&#34;2.12.10&#34;</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">ivyDeps</span> <span class="k">=</span> <span class="nc">Agg</span><span class="o">(</span>
    <span class="n">ivy</span><span class="s">&#34;edu.berkeley.cs::firrtl:1.2.0&#34;</span>
  <span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">chisel3</span> <span class="k">extends</span> <span class="nc">CommonChiselModule</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">chiselFrontend</span> <span class="k">extends</span> <span class="nc">CommonChiselModule</span>
  <span class="k">def</span> <span class="n">moduleDeps</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">chiselFrontend</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">millSourcePath</span> <span class="k">=</span> <span class="k">super</span><span class="o">.</span><span class="n">millSourcePath</span> <span class="o">/</span> <span class="n">ammonite</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">up</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里用的 <strong>Scala</strong> 版本是 <code>2.12.10</code>，依赖 <strong>firrtl</strong> 的 <code>1.2.0</code> 版本。</p>

<p>项目名字叫 <strong>chisel3</strong> ，在使用 <strong>Mill</strong> 进行编译或者是运行时，需要带上项目的名字。</p>

<ul>
<li>编译源代码：<code>mill chisel3.compile</code></li>
<li>编译并运行：<code>mill chisel3.run</code></li>
</ul>

<p>子项目是 <strong>chiselFrontend</strong>，因为用到宏 <strong>Macro</strong> ，需要把宏相关的放到一个单独的编译项目。需要先编译宏定义的项目之后，才去编译使用宏的项目。虽然目前不会用到宏，但还是保留了这样一个项目结构。</p>

<p><code>def moduleDeps = Seq(chiselFrontend)</code> 定义了编译顺序。</p>

<p>即先编译 <code>chiselFrontend</code> (<code>play-chisel/chiselFrontend/src</code> 的源码) 再轮到 <code>chisel3</code>（<code>play-chisel/chisel3/src</code>的源码）。</p>

<p>源码默认是需要放在 <code>play-chisel/chisel3/src</code> 的目录里，但 <code>def millSourcePath = super.millSourcePath / ammonite.ops.up</code> 让寻找源代码的路径往上挪了一级。也就是说，原来 <strong>Mill</strong> 是去 <code>play-chisel/chisel3</code> 寻找 <code>src</code> 目录，现在改成去 <code>play-chisel</code> 找。</p>

<p>新建文件夹 <code>src</code>，编辑 <code>Main.scala</code>，用来存放程序的入口函数，相当于 <strong>C</strong> 语言的 <code>main</code> 函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir src
$ touch src/Main.scala</code></pre></td></tr></table>
</div>
</div>
<p><strong>Scala</strong> 是靠代码里定义了 <code>def main</code> 方法的对象或是继承了 <code>App</code> 的对象来作为程序执行的入口，下面是最简单的 <em>Hello, world</em> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/Main.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">playchisel</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&#34;Hello, world&#34;</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>执行 <em>Mill</em> 构建项目并运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码01</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap01-01">play-chisel/tree/chap01-01</a></p>

<h1 id="搭建基本的-chisel-框架">搭建基本的 Chisel 框架</h1>

<p>这一小节主要是把 <strong>Chisel</strong> 需要的基本类型都简单地定义一遍，为了方便通过编译，基本上都是定义了类型，满足编译器的类型检查，不会做有实际意义的事情。</p>

<h2 id="main-scala">Main.scala</h2>

<p><code>Main.scala</code> 做了四件事情：</p>

<ol>
<li>继承 <code>RawModule</code> 定义二选一的多路选择器；</li>
<li>调用 <code>Builder.build</code> 方法构建出中间语言表示（<strong>IR</strong>）的电路；</li>
<li>调用 <code>Emitter.emit</code> 方法解析 <strong>IR</strong> 生成 <strong>FIRRTL</strong> 字符串；</li>
<li>例化 <code>FileWriter</code> 把字符串写入文件。</li>
</ol>

<p>二选一的多路选择器 <code>Mux2</code> 只是简单地继承了 <code>RawModule</code>，具体要做的事情留到下一小节。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/Main.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">playchisel</span>

<span class="k">import</span> <span class="nn">chisel3._</span>
<span class="k">import</span> <span class="nn">chisel3.internal.Builder</span>
<span class="k">import</span> <span class="nn">chisel3.internal.firrtl._</span>

<span class="k">import</span> <span class="nn">java.io.</span><span class="o">{</span><span class="nc">File</span><span class="o">,</span> <span class="nc">FileWriter</span><span class="o">}</span>

<span class="k">class</span> <span class="nc">Mux2</span> <span class="k">extends</span> <span class="nc">RawModule</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">circuit</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Builder</span><span class="o">.</span><span class="n">build</span><span class="o">(</span><span class="nc">Module</span><span class="o">(</span><span class="k">new</span> <span class="nc">Mux2</span><span class="o">))</span>

  <span class="k">val</span> <span class="n">emitted</span> <span class="k">=</span> <span class="nc">Emitter</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">circuit</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">file</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">&#34;Mux2.fir&#34;</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">w</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
  <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">emitted</span><span class="o">)</span>
  <span class="n">w</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="builder">Builder</h2>

<p>新建文件夹 <code>chiselFrontend/src/internal</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir -p chiselFrontend/src/internal
$ touch chiselFrontend/src/internal/Builder.scala</code></pre></td></tr></table>
</div>
</div>
<p><code>Builder.scala</code> 除了 <code>object Builder</code> 之外，还有 <code>trait HasId</code>。 <strong>Chisel</strong> 相关的元素类型都会继承于 <code>HasId</code>。</p>

<p><code>object Builder</code> 定义了跟生成电路 <strong>IR</strong> 相关的变量和方法，目前先简单定义 <code>def build</code> 方法，只是满足返回值的类型检查。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3.internal</span>

<span class="k">import</span> <span class="nn">chisel3._</span>
<span class="k">import</span> <span class="nn">chisel3.internal.firrtl._</span>

<span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">trait</span> <span class="nc">HasId</span>

<span class="k">object</span> <span class="nc">Builder</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">build</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">RawModule</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Circuit</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&#34;Elaborating design...&#34;</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">mod</span> <span class="k">=</span> <span class="n">f</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&#34;Done elaborating.&#34;</span><span class="o">)</span>
    <span class="o">(</span><span class="nc">Circuit</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">,</span> <span class="nc">Seq</span><span class="o">()),</span> <span class="n">mod</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Builder.build</code> 方法的参数是 <code>bc: =&gt; T</code> ，也就是引用传递，不会在传递参数的时候立刻执行，而是等到使用这个参数的时候。因此，<code>Builder</code> 的属性初始化之后（这里目前只有输出一句 <code>&quot;Elaborating design...&quot;</code>)，它的参数才会被执行 <code>val mod = f</code> 。</p>

<p>返回值类型是<code>（Circuit, T)</code> , 也就是返回中间语言表示（<strong>IR</strong>）的电路 <code>Circuit</code> 以及模块自身，类型必须是 <code>RawModule</code> 的子类（<code>T&lt;:RawModule</code>) 。 <code>(Circuit(&quot;&quot;, Seq()), mod)</code> 目前返回空的电路 <code>Circuit(&quot;&quot;, Seq())</code> 和参数中例化过的模块 <code>mod</code> 。</p>

<p>这里简单解释下电路 <strong>IR</strong> <code>Circuit(&quot;&quot;, Seq())</code>，第一个参数是电路的名字，为空字符串；第二个参数是电路里的 <strong>Verilog</strong> 模块列表，目前为空，什么模块也还没有。</p>

<h2 id="module">Module</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/Module.scala</code></pre></td></tr></table>
</div>
</div>
<p><code>Module.scala</code> 除了 <code>object Module</code> 之外还有放在 <code>package experimental</code> 里用来生成 <strong>Verilog</strong> 模块端口的 <code>object IO</code> 和 <strong>Verilog</strong> 模块的基类 <code>BaseModule</code> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3</span>

<span class="k">import</span> <span class="nn">chisel3.internal._</span>

<span class="k">object</span> <span class="nc">Module</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">BaseModule</span><span class="o">](</span><span class="n">bc</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">module</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">bc</span>
    <span class="n">module</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">package</span> <span class="nn">experimental</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">IO</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="k">&lt;:</span><span class="kt">Data</span><span class="o">](</span><span class="n">iodef</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">iodef</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span></code></pre></td></tr></table>
</div>
</div>
<p><code>object Module</code> 目前只有一个 <code>apply</code> 方法，接受的参数类型是 <code>BaseModule</code> 的子类，<code>=&gt; T</code> 表示引用类型，传参的时候不会执行，等到执行了 <code>val module: T = bc</code> 才执行。目前什么也没有做，只是满足类型检查，返回参数自身。</p>

<p><code>object IO</code> 也是什么也不做，仅仅是返回参数自身。</p>

<p><code>BaseModule</code> 也只是继承了 <code>HasId</code> 而已（<strong>Chisel</strong> 相关的元素都会继承 <code>HasId</code>）。</p>

<h2 id="rawmodule">RawModule</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/RawModule.scala</code></pre></td></tr></table>
</div>
</div>
<p>生成的 <strong>Verilog</strong> 模块分为两种，一种是定义了端口和实现的模块，比如这个例子里的二选一多路选择器；另一种是只定义端口，没有实现，用于例化子模块，比如 <strong>BlackBox</strong>。</p>

<p><strong>RawModule</strong> 属于定义了端口和实现的 <strong>Verilog</strong> 模块的基类。不会像 <strong>Module</strong>（<strong>RawModule</strong> 的子类）帮用户定义好了时钟 <code>clock</code> 和同步复位 <code>reset</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/RawModule.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">RawModule</span> <span class="k">extends</span> <span class="nc">BaseModule</span></code></pre></td></tr></table>
</div>
</div>
<p><code>RawModule.scala</code> 只有 <code>abstract class RawModule</code> ，<code>RawModule</code> 也只是继承了 <code>BaseModule</code> ，什么也不做。</p>

<h2 id="ir">IR</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir -p chiselFrontend/src/internal/firrtl
$ touch chiselFrontend/src/internal/firrtl/IR.scala</code></pre></td></tr></table>
</div>
</div>
<p><strong>Chisel</strong> 会把用户写的模块信息先收集好，比如端口信息，电路的基本元素（<strong>Wire</strong>， <strong>Reg</strong>），以及它们的连接方式等等，存到一组定义好的数据结构里统一起来，在用户写的 <strong>Chisel</strong> 和生成的 <strong>FIRRTL</strong> 中间多了一层，成为 <strong>IR</strong>（Intermediate Representation），中间表示或中间语言表示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/IR.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3.internal.firrtl</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Width</span>
<span class="k">sealed</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">UnknownWidth</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">Width</span>
<span class="k">sealed</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">KnownWidth</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Width</span>

<span class="k">object</span> <span class="nc">Width</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="nc">KnownWidth</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="nc">UnknownWidth</span><span class="o">()</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Component</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Circuit</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">components</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Component</span><span class="o">])</span></code></pre></td></tr></table>
</div>
</div>
<p><code>IR.scala</code> 主要存放的是中间语言表示（<strong>IR</strong>）相关的数据类型。</p>

<p><code>Width</code> 表示的是 <strong>Verilog</strong> 数据宽度，未知宽度 <code>UnknownWidth</code> 和已知宽度 <code>KnownWidth</code>。</p>

<p><code>Component</code> 表示的是 <code>Verilog</code> 里的模块。</p>

<p><code>Circuit</code> 电路包括了自己的名字 <code>name: String</code>和它里面包含的所有 <strong>Verilog</strong> 模块 <code>components: Seq[Component]</code>。</p>

<h2 id="data-scala">Data.scala</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/Data.scala</code></pre></td></tr></table>
</div>
</div>
<p><code>Data</code> 是定义 <strong>Verilog</strong> 数据的基类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3</span>

<span class="k">import</span> <span class="nn">chisel3.internal._</span>
<span class="k">import</span> <span class="nn">chisel3.internal.firrtl._</span>

<span class="k">object</span> <span class="nc">Input</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="k">&lt;:</span><span class="kt">Data</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">source</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Output</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="k">&lt;:</span><span class="kt">Data</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">source</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Data</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">connect</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Data</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{}</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Width</span>
  <span class="k">final</span> <span class="k">def</span> <span class="k">:</span><span class="o">=</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Data</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Data.scala</code> 里有 <code>Input</code> 和 <code>Output</code> 用来定义端口是输入还是输出。这里也只是返回参数，没有做其他的事情。</p>

<p><code>abstract class Data</code> 继承了 <code>HasId</code> ，它是有宽度 <code>width</code>的，<code>def :=</code> 方法是方便用户调用 <code>def connect</code> 方法的 <strong>API</strong>，用来把 <code>:=</code> 两边的数据连接到一起，相当于 <strong>Verilog</strong> 里的赋值语句。</p>

<h2 id="element-scala">Element.scala</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/Element.scala</code></pre></td></tr></table>
</div>
</div>
<p><strong>Element</strong> 是一个“叶子” <strong>Verilog</strong> 数据类型：它不会包含其他<code>Data</code> 类派生的 <strong>Verilog</strong> 数据类型，用来表示原语（ <em>primitive data types</em> ）的数据类型，像整型（ <em>integers</em> ）和比特类型（ <em>bits</em> ）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Element.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="k">extends</span> <span class="nc">Data</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Element</code> 这里只是继承了 <code>Data</code>，没有做其他的事情。</p>

<h2 id="num-scala">Num.scala</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/Num.scala</code></pre></td></tr></table>
</div>
</div>
<p><code>trait Num</code> 里定义了一系列用于 <strong>Verilog</strong> 数值类型的操作，目前这里为空。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Num.scala
</span><span class="c1"></span>
<span class="k">package</span> <span class="nn">chisel3</span>
<span class="k">trait</span> <span class="nc">Num</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Data</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">self</span><span class="k">:</span> <span class="kt">Num</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>T&lt;:Data</code> 和 <code>self: Num[T] =&gt;</code> 在继承的时候限定了里面定义的方法只能是用于某一个 <code>Data</code>子类的数据类型，比如 <code>class UInt extends Num[UInt]</code>，那么这些定义的方法只能用于 <code>UInt</code>。</p>

<h2 id="bits-scala">Bits.scala</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/Bits.scala</code></pre></td></tr></table>
</div>
</div>
<p><code>Bits</code> 表示该数据类型是有一个或多个比特的，同时定义了基本的位运算方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Bits.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3</span>

<span class="k">import</span> <span class="nn">chisel3.internal.firrtl._</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Bits</span><span class="o">(</span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">UInt</span> <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Bits</span><span class="o">(</span><span class="n">width</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Num</span><span class="o">[</span><span class="kt">UInt</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
    <span class="s">s&#34;UInt</span><span class="si">$width</span><span class="s">&#34;</span>
  <span class="o">}</span>

  <span class="k">final</span> <span class="k">def</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">UInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=</span> <span class="n">that</span>
  <span class="k">final</span> <span class="k">def</span> <span class="o">|</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">UInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=</span> <span class="n">that</span>
  <span class="k">def</span> <span class="n">unary_~</span> <span class="o">()</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=</span> <span class="nc">UInt</span><span class="o">(</span><span class="n">width</span> <span class="k">=</span> <span class="n">width</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Bits.scala</code> 定义了对应到 <strong>Verilog</strong> 里的数据类型，目前只有无符号整型 <code>UInt</code> 一种，并定义了两个 <code>UInt</code> 数据类型之间可以进行与 <code>&amp;</code>、 或 <code>|</code> 、非 <code>~</code> 三种位运算（ <em>Bitwise</em> ）。</p>

<h2 id="uintfactory-scala">UIntFactory.scala</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/UIntFactory.scala</code></pre></td></tr></table>
</div>
</div>
<p><code>UIntFactory</code> 方便用户创建 <code>UInt</code> 类型。咧威猜测为什么不直接定义 <code>object UInt</code> 而是先定义了 <code>UIntFactory</code> 再 <code>object UInt extends UIntFactory</code>，可能是因为 <code>UInt</code> 和 <code>Bits</code> 等价。把它俩做的事情抽象成独立的 <code>trait</code> ，然后继承了 <code>UIntFactory</code> 就好了：<code>object UInt extends UIntFactory</code> 和 <code>object Bits extends UIntFactory</code>。不过这里 <code>Bits</code> 先不细讲。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/UIntFactory.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3</span>

<span class="k">import</span> <span class="nn">chisel3.internal.firrtl.Width</span>

<span class="k">trait</span> <span class="nc">UIntFactory</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Width</span><span class="o">())</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UInt</span><span class="o">(</span><span class="n">width</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>不带宽度参数的 <code>apply()</code> 是创建让 <strong>Chisel</strong> 帮用户自动推导宽度的 <code>UInt</code>（自动推导宽度这里先不做），<code>apply(width: Width)</code>是根据用户指定的宽度创建 <code>UInt</code>。</p>

<h2 id="package-scala">package.scala</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/package.scala</code></pre></td></tr></table>
</div>
</div>
<p><code>package object chisel3</code> 定义的是在 <code>chisel3</code> 这个包的全局变量和函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/package.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">object</span> <span class="n">chisel3</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">internal.firrtl.</span><span class="o">{</span><span class="nc">Width</span><span class="o">}</span>

  <span class="k">import</span> <span class="nn">scala.language.implicitConversions</span>

  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">fromIntToWidth</span><span class="o">(</span><span class="n">int</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">W</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="nc">Width</span><span class="o">(</span><span class="n">int</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">object</span> <span class="nc">UInt</span> <span class="k">extends</span> <span class="nc">UIntFactory</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>伴生对象（<strong>Companions</strong>）是要定义同一个文件里的，也就是说， <code>Bits.scala</code> 里的 <code>sealed class UInt</code> 的伴生对象 <code>object UInt</code> 只能定义在同一个文件 <code>Bits.scala</code> 里，否则会报错 <code>error: Companions 'class UInt' and 'object UInt' must be defined in same file</code> 。为了规避这个问题，只需要 <code>import scala.language.implicitConversions</code> 即可。</p>

<p><code>implicit class</code> 的构造函数只支持一个参数，这里是整型 <code>Int</code> 。 当编译器遇到 <code>5.W</code> ，就会去找参数是 <code>Int</code> 类型的隐式 <code>class</code> ，这里是 <code>implicit class fromIntToWidth</code>。找到之后，再去这里个类里找名字叫 <code>W</code> 的方法，找到了就会调用执行，因此 <code>5.W</code> 相当于是 <code>Width(5)</code>。</p>

<p>对于 <code>implicit class</code> 这里再举个简单直观的例子，打开 <strong>Scala</strong>，按照下面步骤自己尝试一遍。这里给整型 <code>Int</code> 定义一个方法<code>S</code>，将一个整型转换成字符串： <code>10.S</code> 输出 <code>&quot;10&quot;</code>。</p>

<p>一开始输入 <code>10.S</code> 会报错，因为我们还没有定义 <code>S</code> 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">scala&gt; <span class="m">10</span>.S
          ^
       error: value S is not a member of Int

scala&gt;</code></pre></td></tr></table>
</div>
</div>
<p>接下来定义 <code>implicit class fromIntToString</code> 类，里面再定义一个 <code>def S: String</code> 方法，没有参数，方法体里面用的是隐式类 <code>implicit class fromIntToString</code> 的参数 <code>int: Int</code>，调用 <code>Int</code> 类型预先定义好的 <code>toString</code> 方法，把整型转换成字符串型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">scala&gt; implicit class fromIntToString<span class="o">(</span>int: Int<span class="o">)</span> <span class="o">{</span>
     <span class="p">|</span>   def S: <span class="nv">String</span> <span class="o">=</span> int.toString
     <span class="p">|</span> <span class="o">}</span>
defined class fromIntToString

scala&gt;</code></pre></td></tr></table>
</div>
</div>
<p>当我们再次输入<code>10.S</code> ，就能输出 <code>&quot;10&quot;</code>了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">scala&gt; <span class="m">10</span>.S
res1: <span class="nv">String</span> <span class="o">=</span> <span class="m">10</span>

scala&gt;</code></pre></td></tr></table>
</div>
</div>
<h2 id="emitter-scala">Emitter.scala</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir -p src/internal/firrtl
$ touch src/internal/firrtl/Emitter.scala</code></pre></td></tr></table>
</div>
</div>
<p><code>Emitter</code> 里没有涉及到宏，按照 <strong>Chisel</strong> <strong>IR</strong> 划分的话，属于解析 <strong>IR</strong> 的后端，因此源码不是放在 <code>chiselFrontend</code> 子项目里，而是 <code>chisel3</code> 项目里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span>
<span class="k">package</span> <span class="nn">chisel3.internal.firrtl</span>
<span class="k">import</span> <span class="nn">chisel3._</span>

<span class="k">object</span> <span class="nc">Emitter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">emit</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="o">).</span><span class="n">toString</span>
<span class="o">}</span>

<span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&#34;Hello, chisel3&#34;</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Emitter.scala</code> 是把中间语言表示 <strong>IR</strong> 的电路转换成 <strong>FIRRTL</strong>, 目前什么也没有做，只是返回 <code>&quot;Hello, chisel3&quot;</code>。
当执行下面命令的时候，会生成 <code>Mux2.fir</code> 文件，里面只有一句 <code>&quot;Hello, chisel3&quot;</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<div class="admonition tip"><p class="admonition-title">源码02</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap01-02">play-chisel/tree/chap01-02</a></p>

<h1 id="自底向上继续完善-chisel">自底向上继续完善 Chisel</h1>

<p>把 <code>Main.scala</code> 的 <code>class Mux2</code> 补充完整：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/Main.scala
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Mux2</span> <span class="k">extends</span> <span class="nc">RawModule</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">sel</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">1.</span><span class="n">W</span><span class="o">)))</span>
  <span class="k">val</span> <span class="n">in0</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">1.</span><span class="n">W</span><span class="o">)))</span>
  <span class="k">val</span> <span class="n">in1</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Input</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">1.</span><span class="n">W</span><span class="o">)))</span>
  <span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Output</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="mf">1.</span><span class="n">W</span><span class="o">)))</span>
  <span class="n">io</span><span class="o">.</span><span class="n">out</span> <span class="k">:</span><span class="o">=</span> <span class="o">(</span><span class="n">io</span><span class="o">.</span><span class="n">sel</span> <span class="o">&amp;</span> <span class="n">io</span><span class="o">.</span><span class="n">in1</span><span class="o">)</span> <span class="o">|</span> <span class="o">(~</span><span class="n">io</span><span class="o">.</span><span class="n">sel</span> <span class="o">&amp;</span> <span class="n">io</span><span class="o">.</span><span class="n">in0</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>接下来会根据在 <code>class Mux2</code> 里的出现顺序，依次完善 <code>IO</code> 、<code>Input/Output</code>、与运算<code>&amp;</code>、或运算<code>|</code>、非运算<code>~</code>和连接操作<code>:=</code>。</p>

<h2 id="io-绑定">IO 绑定</h2>

<p>模块的每个端口都需要调用 <code>IO()</code> 记录下来。 <code>object IO</code> 定义在 <code>Module.scala</code> 文件里的 <code>package experimental</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">experimental</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">IO</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="k">&lt;:</span><span class="kt">Data</span><span class="o">](</span><span class="n">iodef</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">module</span> <span class="k">=</span> <span class="nc">Module</span><span class="o">.</span><span class="n">currentModule</span><span class="o">.</span><span class="n">get</span>
      <span class="n">require</span><span class="o">(!</span><span class="n">module</span><span class="o">.</span><span class="n">isClosed</span><span class="o">,</span> <span class="s">&#34;Can&#39;t add more ports after module close&#34;</span><span class="o">)</span>
      <span class="n">requireIsChiselType</span><span class="o">(</span><span class="n">iodef</span><span class="o">,</span> <span class="s">&#34;io type&#34;</span><span class="o">)</span>

      <span class="k">val</span> <span class="n">iodefClone</span> <span class="k">=</span> <span class="n">iodef</span><span class="o">.</span><span class="n">cloneTypeFull</span>
      <span class="n">module</span><span class="o">.</span><span class="n">bindIoInPlace</span><span class="o">(</span><span class="n">iodefClone</span><span class="o">)</span>
      <span class="n">iodefClone</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">protected</span> <span class="k">def</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Data</span><span class="o">](</span><span class="n">iodef</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">chisel3</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="nc">IO</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">iodef</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>IO()</code> 参数 <code>iodef</code> 的类型是 <code>Data</code> 的子类。</p>

<p>先获取当前的模块，检查是否为关闭状态。当模块例化完成之后，也就是当 <code>new Mux2</code> 生成对象，调用它自身的 <code>generateComponent</code> 方法时，模块才会处于关闭状态，即 <code>isClosed</code> 为 <code>true</code>。</p>

<p><code>requireIsChiselType</code> 要求这个数据类型是 <code>chisel type</code> ，也就是说它还不是硬件类型（可综合的）。对应到 <strong>Verilog</strong>，<code>16'h2333</code> 是 <code>chisel type</code> ，而 <code>reg [15:0] foo</code> 是 <code>hardware type</code> 。</p>

<p><code>IO()</code> 不会改变原有的参数，而是调用 <code>cloneTypeFull</code> 方法复制出一份新的，再调用模块的 <code>bindIoInPlace</code> 方法，把端口绑定到当前模块上。</p>

<p>最后返回参数的复制品。</p>

<h3 id="当前模块">当前模块</h3>

<p><code>object Builder</code> 会记录一个构建过程中的当前模块，表示当前正在构建的模块是哪一个。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Builder</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">currentModule</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">BaseModule</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>object Module</code> 的 <code>def currentModule</code> 方法拿到的是当前 <code>object Builder</code> 的 <code>currentModule</code> 变量的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Module</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">currentModule</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">BaseModule</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Builder</span><span class="o">.</span><span class="n">currentModule</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>每次例化一个新的模块时， <code>object Builder</code> 的 <code>currentModule</code> 变量都会指向它。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="nc">Builder</span><span class="o">.</span><span class="n">currentModule</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="模块的关闭状态">模块的关闭状态</h3>

<p>模块的关闭状态是用来区分例化用户定义的模块和生成模块 <strong>IR</strong> 这两个阶段。例化用户定义的模块（比如这里的 <code>Mux2</code>），会收集模块定义相关的信息，比如定义了哪些端口，哪些硬件（<strong>reg</strong> 、 <strong>wire</strong>)，它们之间如何连线等等，这个阶段发生在模块关闭之前；这之后，等到调用模块的 <code>generateComponent</code> 方法生成 <strong>Verilog</strong> 的模块 <strong>IR</strong> 时，处于模块关闭状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">chisel3.internal.firrtl._</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">protected</span> <span class="k">var</span> <span class="nc">_closed</span> <span class="k">=</span> <span class="kc">false</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">isClosed</span> <span class="k">=</span> <span class="nc">_closed</span>
  <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">generateComponent</span><span class="o">()</span><span class="k">:</span> <span class="kt">Component</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>模块初始化的时候，<code>isClosed</code> 是 <code>false</code>，只有等到调用 <code>generateComponent</code> 生成中间语言表示 <strong>IR</strong> 的模块时，<code>isClosed</code> 才设置为 <code>true</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">chisel3.internal.firrtl._</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">RawModule</span> <span class="k">extends</span> <span class="nc">BaseModule</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">generateComponent</span><span class="o">()</span><span class="k">:</span> <span class="kt">Component</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(!</span><span class="nc">_closed</span><span class="o">,</span> <span class="s">&#34;Can&#39;t generate module more than once&#34;</span><span class="o">)</span>
    <span class="nc">_closed</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="k">new</span> <span class="nc">Component</span> <span class="o">{}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="chiseltype-hardwaretype">ChiselType &amp; HardwareType</h3>

<p>这两种类型的判断依据是数据的可综合属性 <code>isSynthesizable</code>，可综合的为硬件类型，不可综合的为 <strong>Chisel</strong> 类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Binding.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3.internal</span>
<span class="k">import</span> <span class="nn">chisel3._</span>

<span class="k">object</span> <span class="nc">requireIsHardware</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">Data</span><span class="o">,</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">node</span><span class="o">.</span><span class="n">isSynthesizable</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">prefix</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span> <span class="s">s&#34;</span><span class="si">$msg</span><span class="s"> &#34;</span> <span class="k">else</span> <span class="s">&#34;&#34;</span>
      <span class="k">throw</span> <span class="nc">ExpectedHardwareException</span><span class="o">(</span><span class="s">s&#34;</span><span class="si">$prefix</span><span class="s">&#39;</span><span class="si">$node</span><span class="s">&#39; must be hardware, &#34;</span> <span class="o">+</span>
        <span class="s">&#34;not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)?&#34;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">requireIsChiselType</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">Data</span><span class="o">,</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="n">isSynthesizable</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">prefix</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span> <span class="s">s&#34;</span><span class="si">$msg</span><span class="s"> &#34;</span> <span class="k">else</span> <span class="s">&#34;&#34;</span>
    <span class="k">throw</span> <span class="nc">ExpectedChiselTypeException</span><span class="o">(</span><span class="s">s&#34;</span><span class="si">$prefix</span><span class="s">&#39;</span><span class="si">$node</span><span class="s">&#39; must be a Chisel type, not hardware&#34;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>requireIsHardware</code> 和 <code>requireIsChiselType</code> 用来检查是否符合各自的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Data</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="nc">_binding</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Binding</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
  <span class="k">protected</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">binding</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Binding</span><span class="o">]</span> <span class="k">=</span> <span class="nc">_binding</span>
  <span class="k">protected</span> <span class="k">def</span> <span class="n">binding_=</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Binding</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">_binding</span><span class="o">.</span><span class="n">isDefined</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="nc">RebindingException</span><span class="o">(</span><span class="s">s&#34;Attempted reassignment of binding to </span><span class="si">$this</span><span class="s">&#34;</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="nc">_binding</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">target</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">bind</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Binding</span><span class="o">,</span> <span class="n">parentDirection</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span> <span class="o">=</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span><span class="o">)</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">final</span> <span class="k">def</span> <span class="n">isSynthesizable</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nc">_binding</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">TopBinding</span> <span class="o">=&gt;</span> <span class="kc">true</span>
  <span class="o">}.</span><span class="n">getOrElse</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Data</code> 数据是否可综合是根据它的 <code>_binding</code> 属性，即它被绑定成了什么类型。目前只有 <code>TopBinding</code> 绑定类型才算是可综合的硬件类型。</p>

<p>这里的 <code>def binding</code> 和 <code>def binding_=</code> 类似于 <code>var binding</code> 。区别在于写的操作上，当赋值给 <code>binding</code> 时，会调用 <code>binding_=</code> 方法，检查是否重复绑定了。</p>

<p>这里只是声明了 <code>def bind</code> 绑定方法，具体的定义留个它的子类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Element.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3</span>

<span class="k">import</span> <span class="nn">chisel3.internal._</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="k">extends</span> <span class="nc">Data</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">override</span> <span class="k">def</span> <span class="n">bind</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Binding</span><span class="o">,</span> <span class="n">parentDirection</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">binding</span> <span class="k">=</span> <span class="n">target</span>
    <span class="k">val</span> <span class="n">resolvedDirection</span> <span class="k">=</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="n">fromParent</span><span class="o">(</span><span class="n">parentDirection</span><span class="o">,</span> <span class="n">specifiedDirection</span><span class="o">)</span>
    <span class="n">direction</span> <span class="k">=</span> <span class="nc">ActualDirection</span><span class="o">.</span><span class="n">fromSpecified</span><span class="o">(</span><span class="n">resolvedDirection</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>目前 <code>Data</code> 的子类只有 <code>Element</code>。<code>Element</code> 类型的数据 <code>bind</code> 绑定方法，需要指定绑定的类型 <code>target: Binding</code>，还设置了数据的方向。</p>

<div class="admonition tip"><p class="admonition-title">注意</p>
  

</div>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Data</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">bind</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Binding</span><span class="o">,</span> <span class="n">parentDirection</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span> <span class="o">=</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="k">extends</span> <span class="nc">Data</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">override</span> <span class="k">def</span> <span class="n">bind</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Binding</span><span class="o">,</span> <span class="n">parentDirection</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def bind</code> 在 <code>abstract class Data</code> 里的定义，参数 <code>parentDirection</code> 是有默认值的，默认父类的指定方向是未定义 <code>SpecifiedDirection.Unspecified</code>。 但在 <code>abstract class Element</code> 的定义里，没有显性地指定的默认值，那么这里是会继承在 <code>abstract class Data</code> 中给定的默认值 <code>SpecifiedDirection.Unspecified</code>。</p>

<p>说到方向，先来定义下数据的方向属性：</p>

<ol>
<li>用户定义的方向 <strong>SpecifiedDirection</strong> ；</li>
<li>被绑定后根据用户指定的（<code>specifiedDirection</code>）解析过的实际方向 <strong>ActualDirection</strong>。</li>
</ol>

<p>它们都是定义在 <code>abstract class Data</code> 的自身属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Data</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="nc">_specifiedDirection</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span> <span class="o">=</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span>

  <span class="k">def</span> <span class="n">specifiedDirection</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span> <span class="o">=</span> <span class="nc">_specifiedDirection</span>
  <span class="k">def</span> <span class="n">specifiedDirection_=</span><span class="o">(</span><span class="n">direction</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">_specifiedDirection</span> <span class="o">!=</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="nc">RebindingException</span><span class="o">(</span><span class="s">s&#34;Attempted reassignment of user-specified direction to </span><span class="si">$this</span><span class="s">&#34;</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="nc">_specifiedDirection</span> <span class="k">=</span> <span class="n">direction</span>
  <span class="o">}</span>
  
  <span class="k">private</span> <span class="k">var</span> <span class="nc">_direction</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">ActualDirection</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">direction</span><span class="k">:</span> <span class="kt">ActualDirection</span> <span class="o">=</span> <span class="nc">_direction</span><span class="o">.</span><span class="n">get</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">direction_=</span><span class="o">(</span><span class="n">actualDirection</span><span class="k">:</span> <span class="kt">ActualDirection</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">_direction</span><span class="o">.</span><span class="n">isDefined</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="nc">RebindingException</span><span class="o">(</span><span class="s">s&#34;Attempted reassignment of resolved direction to </span><span class="si">$this</span><span class="s">&#34;</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="nc">_direction</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">actualDirection</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>它们都用了相同方法名加 <code>_=</code> 的方式：<code>def specifiedDirection</code> 用作读， <code>def specifiedDirection_=(direction: SpecifiedDirection)</code> 用作写的方式，来对写入进行检查。</p>

<p>举个例子，打开 <strong>Scala</strong> 的命令行模式（<strong>REPL</strong>）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">scala&gt; object Num <span class="o">{</span>
    var <span class="nv">_foo</span> <span class="o">=</span> <span class="m">0</span>
    
    def <span class="nv">foo</span> <span class="o">=</span> _foo
    def <span class="nv">foo_</span><span class="o">=(</span>n: Int<span class="o">)</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span>n &lt; <span class="m">0</span><span class="o">)</span>
        println<span class="o">(</span><span class="s2">&#34;n should not less than zero!&#34;</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="nv">_foo</span> <span class="o">=</span> n
    <span class="o">}</span>
  <span class="o">}</span> 
defined object Num
scala&gt; Num.foo 
res1: <span class="nv">Int</span> <span class="o">=</span> <span class="m">0</span>
scala&gt; Num.foo <span class="o">=</span> <span class="m">2</span> 
scala&gt; Num.foo 
res3: <span class="nv">Int</span> <span class="o">=</span> <span class="m">2</span>
scala&gt; Num.foo <span class="o">=</span> -1 
n should not less than zero!
scala &gt; Num.foo 
res5: <span class="nv">Int</span> <span class="o">=</span> <span class="m">2</span></code></pre></td></tr></table>
</div>
</div>
<p>方向不能多次绑定，否则会报错。下面是定义在 <code>package.scala</code> 的报错类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/package.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">object</span> <span class="n">chisel3</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">type</span> <span class="kt">ChiselException</span> <span class="o">=</span> <span class="n">internal</span><span class="o">.</span><span class="nc">ChiselException</span>
  <span class="k">class</span> <span class="nc">BindingException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ChiselException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">RebindingException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">BindingException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">ExpectedChiselTypeException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">BindingException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">ExpectedHardwareException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">BindingException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>ChiselException</code> 是定义在 <code>Error.scala</code> 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Error.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3.internal</span>

<span class="k">class</span> <span class="nc">ChiselException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">cause</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Exception</span><span class="o">(</span><span class="n">message</span><span class="o">,</span> <span class="n">cause</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="绑定的类型-binding">绑定的类型 Binding</h3>

<p>目前的绑定类型只有 <code>TopBinding</code>，也就是可综合的（硬件类型的）绑定。 <code>location</code> 记录的是所在的模块。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Binding.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Binding</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">location</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">BaseModule</span><span class="o">]</span>
<span class="o">}</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">TopBinding</span> <span class="k">extends</span> <span class="nc">Binding</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="复制方法-clonetypefull">复制方法 cloneTypeFull</h3>

<p>除了会根据原来的类型实例化新的对象之外，还会复制它的指定方向属性 <code>specifiedDirection</code> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Data</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cloneType</span><span class="k">:</span> <span class="kt">this.type</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">cloneTypeFull</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// get a fresh object, without bindings
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">clone</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">cloneType</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">this.</span><span class="k">type</span><span class="o">]</span>
    <span class="c1">// Only the top-level direction needs to be fixed up, cloneType should do the rest
</span><span class="c1"></span>    <span class="n">clone</span><span class="o">.</span><span class="n">specifiedDirection</span> <span class="k">=</span> <span class="n">specifiedDirection</span>
    <span class="n">clone</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>带有宽度的 <code>Bits</code> 数据类型，它的复制方法是连宽度一块复制。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Bits.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">chisel3.internal.firrtl._</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Bits</span><span class="o">(</span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">cloneTypeWidth</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.type</span>

  <span class="k">def</span> <span class="n">cloneType</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="n">cloneTypeWidth</span><span class="o">(</span><span class="n">width</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def cloneTypeWidth</code> 在 <code>Bits</code> 的子类里定义，比如 <code>UInt</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Bits.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">class</span> <span class="nc">UInt</span> <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Bits</span><span class="o">(</span><span class="n">width</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Num</span><span class="o">[</span><span class="kt">UInt</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">override</span> <span class="k">def</span> <span class="n">cloneTypeWidth</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">UInt</span><span class="o">(</span><span class="n">w</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">this.</span><span class="k">type</span><span class="o">]</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="绑定io端口">绑定IO端口</h3>

<p>绑定 IO 端口的方法 <code>bindIoInPlace</code> 先把端口数据 <code>iodef: Data</code> 注册为端口类型 <code>PortBinding</code>，然后添加到该模块的端口列表里 <code>_ports</code> 。<strong>注意</strong>：这里的 <code>iodef.bind()</code> 没有给定第二个 <code>parentDirection</code> 参数，用的是默认值 <code>SpecifiedDirection.Unspecified</code> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">protected</span> <span class="k">def</span> <span class="nc">_bindIoInPlace</span><span class="o">(</span><span class="n">iodef</span><span class="k">:</span> <span class="kt">Data</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">iodef</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="nc">PortBinding</span><span class="o">(</span><span class="k">this</span><span class="o">))</span>
    <span class="nc">_ports</span> <span class="o">+=</span> <span class="n">iodef</span>
  <span class="o">}</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">bindIoInPlace</span><span class="o">(</span><span class="n">iodef</span><span class="k">:</span> <span class="kt">Data</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nc">_bindIoInPlace</span><span class="o">(</span><span class="n">iodef</span><span class="o">)</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>端口的绑定类型记录下被绑定到哪个模块上 <code>enclosure: BaseModule</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Binding.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ConstrainedBinding</span> <span class="k">extends</span> <span class="nc">TopBinding</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">enclosure</span><span class="k">:</span> <span class="kt">BaseModule</span>
  <span class="k">def</span> <span class="n">location</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">BaseModule</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">enclosure</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">PortBinding</span><span class="o">(</span><span class="n">enclosure</span><span class="k">:</span> <span class="kt">BaseModule</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ConstrainedBinding</span></code></pre></td></tr></table>
</div>
</div>
<p><code>_ports</code> 记录了该模块的端口列表，获取端口列表通过 <code>getModulePorts</code> 方法，并且只能在关闭状态，也就是 <code>generateComponent</code> 方法里面才能调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">val</span> <span class="nc">_ports</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Data</span><span class="o">]()</span>

  <span class="k">protected</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">getModulePorts</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="nc">_closed</span><span class="o">,</span> <span class="s">&#34;Can&#39;t get ports before module close&#34;</span><span class="o">)</span>
    <span class="nc">_ports</span><span class="o">.</span><span class="n">toSeq</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="input-output">Input/Output</h2>

<p><code>object Input</code> 和 <code>object Output</code> 是让用户改变数据的方向，即改变数据的 <code>specifiedDirection</code> 属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Input</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="k">&lt;:</span><span class="kt">Data</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="n">specifiedDirection</span><span class="o">(</span><span class="n">source</span><span class="o">)(</span><span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Input</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Output</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="k">&lt;:</span><span class="kt">Data</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="n">specifiedDirection</span><span class="o">(</span><span class="n">source</span><span class="o">)(</span><span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Output</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Input</code> 是调用 <code>specifiedDirection</code> 方法改变数据的方向为输入，<code>Output</code> 是调用 <code>specifiedDirection</code> 方法改变数据的方向为输出。</p>

<p><code>SpecifiedDirection</code> 类型是由用户指定的方向类型，分别为未定义 <code>Unspecified</code>、输出 <code>Output</code>、输入 <code>Input</code> 和反转 <code>Flip</code> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">SpecifiedDirection</span>
<span class="k">object</span> <span class="nc">SpecifiedDirection</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Unspecified</span> <span class="k">extends</span> <span class="nc">SpecifiedDirection</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Output</span>      <span class="k">extends</span> <span class="nc">SpecifiedDirection</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Input</span>       <span class="k">extends</span> <span class="nc">SpecifiedDirection</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Flip</span>        <span class="k">extends</span> <span class="nc">SpecifiedDirection</span>

  <span class="k">def</span> <span class="n">flip</span><span class="o">(</span><span class="n">dir</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">)</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span> <span class="o">=</span> <span class="n">dir</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Unspecified</span> <span class="k">=&gt;</span> <span class="nc">Flip</span>
    <span class="k">case</span> <span class="nc">Flip</span>        <span class="k">=&gt;</span> <span class="nc">Unspecified</span>
    <span class="k">case</span> <span class="nc">Output</span>      <span class="k">=&gt;</span> <span class="nc">Input</span>
    <span class="k">case</span> <span class="nc">Input</span>       <span class="k">=&gt;</span> <span class="nc">Output</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">fromParent</span><span class="o">(</span><span class="n">parentDirection</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">,</span> <span class="n">thisDirection</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">)</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span> <span class="o">=</span>
    <span class="o">(</span><span class="n">parentDirection</span><span class="o">,</span> <span class="n">thisDirection</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Output</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Output</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Input</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Input</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span><span class="o">,</span> <span class="n">thisDirection</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">thisDirection</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Flip</span><span class="o">,</span> <span class="n">thisDirection</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="n">flip</span><span class="o">(</span><span class="n">thisDirection</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">specifiedDirection</span><span class="o">[</span><span class="kt">T</span><span class="k">&lt;:</span><span class="kt">Data</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">dir</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cloneType</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
    <span class="n">out</span><span class="o">.</span><span class="n">specifiedDirection</span> <span class="k">=</span> <span class="n">dir</span>
    <span class="n">out</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>反转方法 <code>def flip</code> 是把未定义变成反转，反转变成未定义，输出变成输入，输入变成输出。</p>

<p>根据父类的和当前的指定方向来决定最终的指定方向 <code>def fromParent</code>，如果父类的指定方向是输入/输出，不用考虑当前的指定方向，得到的是对应的输入/输出；如果父类未定义，则按照当前的指定方向；如果父类是反转类型，那么要相应地反转当前的指定方向。</p>

<p>指定方向的方法 <code>def specifiedDirection</code> 是把 <code>Data</code> 的子类复制一份，然后把复制品的方向改变为指定的方向类型。</p>

<p>实际方向类型有空 <code>Empty</code> 、未定义 <code>Unspecified</code> 、输出 <code>Output</code> 和输入 <code>Input</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">ActualDirection</span>
<span class="k">object</span> <span class="nc">ActualDirection</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span>       <span class="k">extends</span> <span class="nc">ActualDirection</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Unspecified</span> <span class="k">extends</span> <span class="nc">ActualDirection</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Output</span>      <span class="k">extends</span> <span class="nc">ActualDirection</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Input</span>       <span class="k">extends</span> <span class="nc">ActualDirection</span>

  <span class="k">def</span> <span class="n">fromSpecified</span><span class="o">(</span><span class="n">direction</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">)</span><span class="k">:</span> <span class="kt">ActualDirection</span> <span class="o">=</span> <span class="n">direction</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span> <span class="o">|</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Flip</span> <span class="k">=&gt;</span> <span class="nc">ActualDirection</span><span class="o">.</span><span class="nc">Unspecified</span>
    <span class="k">case</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Output</span> <span class="k">=&gt;</span> <span class="nc">ActualDirection</span><span class="o">.</span><span class="nc">Output</span>
    <span class="k">case</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Input</span> <span class="k">=&gt;</span> <span class="nc">ActualDirection</span><span class="o">.</span><span class="nc">Input</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>从指定方向变成真正的方向类型方法 <code>def fromSpecified</code> 会把未定义、反转的指定类型变成未定义的实际方向类型，把输出的指定类型变成输出的实际类型，把输入的指定类型变成输入的实际类型。</p>

<h2 id="command-命令">Command 命令</h2>

<p><strong>Chisel</strong> 会把生成 <strong>Verilog</strong> 模块里定义的运算语句，比如这里的位运算，以及赋值语句称为一条命令（<strong>Command</strong>）。</p>

<h3 id="位运算">位运算</h3>

<p>与、或位运算都是二元运算（<em>binop: binary operation</em>)， 非位运算是一元运算（<em>unop: unary operation</em>) 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Bits.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">chisel3.internal.Builder.pushOp</span>
<span class="k">import</span> <span class="nn">chisel3.internal.firrtl.PrimOp._</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">UInt</span> <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Bits</span><span class="o">(</span><span class="n">width</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Num</span><span class="o">[</span><span class="kt">UInt</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">final</span> <span class="k">def</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">UInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=</span>
    <span class="n">binop</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">width</span> <span class="n">max</span> <span class="n">that</span><span class="o">.</span><span class="n">width</span><span class="o">),</span> <span class="nc">BitAndOp</span><span class="o">,</span> <span class="n">that</span><span class="o">)</span>
  <span class="k">final</span> <span class="k">def</span> <span class="o">|</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">UInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=</span>
    <span class="n">binop</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">width</span> <span class="n">max</span> <span class="n">that</span><span class="o">.</span><span class="n">width</span><span class="o">),</span> <span class="nc">BitOrOp</span><span class="o">,</span> <span class="n">that</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">unary_~</span> <span class="o">()</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=</span>
    <span class="n">unop</span><span class="o">(</span><span class="nc">UInt</span><span class="o">(</span><span class="n">width</span> <span class="k">=</span> <span class="n">width</span><span class="o">),</span> <span class="nc">BitNotOp</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>二元运算结果的宽度取自两个操作数的宽度最大值。</p>

<p>计算出两个宽度 <code>Width</code> 最大值的 <code>max</code> 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/IR.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Width</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">W</span> <span class="o">=</span> <span class="nc">Int</span>
  <span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">op</span><span class="o">(</span><span class="n">that</span><span class="o">,</span> <span class="k">_</span> <span class="n">max</span> <span class="k">_</span><span class="o">)</span>

  <span class="k">protected</span> <span class="k">def</span> <span class="n">op</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Width</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">W</span><span class="o">,</span> <span class="kt">W</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">W</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span>
<span class="o">}</span>
<span class="k">sealed</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">UnknownWidth</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">Width</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">op</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Width</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">W</span><span class="o">,</span> <span class="kt">W</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">W</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&#34;&#34;</span>
<span class="o">}</span>
<span class="k">sealed</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">KnownWidth</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Width</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">op</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Width</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">W</span><span class="o">,</span> <span class="kt">W</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">W</span><span class="o">)</span><span class="k">:</span> <span class="kt">Width</span> <span class="o">=</span> <span class="n">that</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">KnownWidth</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">KnownWidth</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">that</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">s&#34;&lt;</span><span class="si">${</span><span class="n">value</span><span class="o">.</span><span class="n">toString</span><span class="si">}</span><span class="s">&gt;&#34;</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>二元运算与一元运算的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Bits.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Bits</span><span class="o">(</span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Width</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">unop</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Data</span><span class="o">](</span><span class="n">dest</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">op</span><span class="k">:</span> <span class="kt">PrimOp</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">requireIsHardware</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&#34;bits operated on&#34;</span><span class="o">)</span>
    <span class="n">pushOp</span><span class="o">(</span><span class="nc">DefPrim</span><span class="o">(</span><span class="n">dest</span><span class="o">,</span> <span class="n">op</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">ref</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">binop</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Data</span><span class="o">](</span><span class="n">dest</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">op</span><span class="k">:</span> <span class="kt">PrimOp</span><span class="o">,</span> <span class="n">other</span><span class="k">:</span> <span class="kt">Bits</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">requireIsHardware</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&#34;bits operated on&#34;</span><span class="o">)</span>
    <span class="n">requireIsHardware</span><span class="o">(</span><span class="n">other</span><span class="o">,</span> <span class="s">&#34;bits operated on&#34;</span><span class="o">)</span>
    <span class="n">pushOp</span><span class="o">(</span><span class="nc">DefPrim</span><span class="o">(</span><span class="n">dest</span><span class="o">,</span> <span class="n">op</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">ref</span><span class="o">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ref</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>一元运算是生成一个运算结果、运算类型和操作数（自身）的三元组 <code>DefPrim(dest, op, this.ref)</code> 命令；</li>
<li>二元运算是生成一个运算结果、运算类型、操作数（自身)和操作数（另一个）的四元组 <code>DefPrim(dest, op, this.ref, other.ref)</code> 命令。</li>
</ul>

<p>一元和二元运算是把运算结果，运算类型，以及参数列表放在了 <code>DefPrim</code> 数据类型里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/IR.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">chisel3._</span>
<span class="k">import</span> <span class="nn">chisel3.internal._</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Command</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Definition</span> <span class="k">extends</span> <span class="nc">Command</span>  <span class="o">{</span>
  <span class="k">def</span> <span class="n">id</span><span class="k">:</span> <span class="kt">HasId</span>
  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">id</span><span class="o">.</span><span class="n">getRef</span><span class="o">.</span><span class="n">name</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">DefPrim</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Data</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">op</span><span class="k">:</span> <span class="kt">PrimOp</span><span class="o">,</span> <span class="n">args</span><span class="k">:</span> <span class="kt">Arg*</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Definition</span></code></pre></td></tr></table>
</div>
</div>
<p><code>PrimOp</code> 基本运算类型，目前只有 <code>BitAndOp</code> 、 <code>BitOrOp</code> <code>BitNotOp</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">PrimOp</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">name</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">PrimOp</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">BitAndOp</span> <span class="k">=</span> <span class="nc">PrimOp</span><span class="o">(</span><span class="s">&#34;and&#34;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">BitOrOp</span>  <span class="k">=</span> <span class="nc">PrimOp</span><span class="o">(</span><span class="s">&#34;or&#34;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">BitNotOp</span> <span class="k">=</span> <span class="nc">PrimOp</span><span class="o">(</span><span class="s">&#34;not&#34;</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>this.ref</code> 和 <code>other.ref</code>里的引用属性 <code>ref</code> 是根据 <code>topBindingOpt</code> 方法来决定是否为节点 <code>Node</code> 类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Data</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">topBindingOpt</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">TopBinding</span><span class="o">]</span> <span class="k">=</span> <span class="nc">_binding</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">bindingVal</span><span class="k">:</span> <span class="kt">TopBinding</span> <span class="o">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">bindingVal</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">ref</span><span class="k">:</span> <span class="kt">Arg</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">requireIsHardware</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
    <span class="n">topBindingOpt</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">binding</span><span class="k">:</span> <span class="kt">TopBinding</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Node</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">opt</span> <span class="k">=&gt;</span> <span class="n">throwException</span><span class="o">(</span><span class="s">s&#34;internal error: unknown binding </span><span class="si">$opt</span><span class="s"> in generating LHS ref&#34;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>目前 <code>def topBindingOpt</code> 返回的都是 <code>TopBinding</code> 类型，因为当前只定义了这么一种，所以 <code>.ref</code> 调用 <code>def ref</code> 方法的都会返回 <code>Node</code> 节点类型。</p>

<p>而 <code>abstract class Definition</code> 里 <code>def name: String = id.getRef.name</code> 的 <code>getRef</code> 方法用到的 <code>_ref</code> 跟 <code>ref</code> 方法不一样。</p>

<ul>
<li><code>ref</code> 主要是作为命令的操作数，比如 <code>DefPrim(dest, op, this.ref)</code>；</li>
<li><code>_ref</code> 配合 <code>getRef</code>、<code>setRef</code> 方法来读取或改变自身的值，用于绑定自身的名字，比如 <code>id.getRef.name</code>。</li>
</ul>

<p>因为这两个名字太相似，容易混淆。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">trait</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">var</span> <span class="nc">_ref</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Arg</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">setRef</span><span class="o">(</span><span class="n">imm</span><span class="k">:</span> <span class="kt">Arg</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nc">_ref</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">imm</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">getRef</span><span class="k">:</span> <span class="kt">Arg</span> <span class="o">=</span> <span class="nc">_ref</span><span class="o">.</span><span class="n">get</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">getOptionRef</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Arg</span><span class="o">]</span> <span class="k">=</span> <span class="nc">_ref</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Arg</code> 参数类型目前只有：<code>Node</code> 节点 和 <code>Ref</code>引用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/IR.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Arg</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fullName</span><span class="o">(</span><span class="n">ctx</span><span class="k">:</span> <span class="kt">Component</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">name</span>
  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">HasId</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Arg</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fullName</span><span class="o">(</span><span class="n">ctx</span><span class="k">:</span> <span class="kt">Component</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">id</span><span class="o">.</span><span class="n">getOptionRef</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">arg</span><span class="o">.</span><span class="n">fullName</span><span class="o">(</span><span class="n">ctx</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">id</span><span class="o">.</span><span class="n">suggestedName</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">&#34;??&#34;</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">id</span><span class="o">.</span><span class="n">getOptionRef</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">id</span><span class="o">.</span><span class="n">suggestedName</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">&#34;??&#34;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Ref</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Arg</span></code></pre></td></tr></table>
</div>
</div>
<p>用户建议的名字 <code>suggestedName</code>，只能被设置一次。之后的设置都会被忽略。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">trait</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">suggested_name</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

  <span class="k">def</span> <span class="n">suggestName</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="o">=&gt;</span><span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">suggested_name</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">suggested_name</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
    <span class="k">this</span>
  <span class="o">}</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">suggestedName</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">suggested_name</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>添加命令 <code>pushOp</code> 的方法先把运算的结果绑定为 <code>OpBinding</code> 类型，并添加到当前模块存放命令列表 <code>_commands</code> 数据结构里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Builder</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">forcedUserModule</span><span class="k">:</span> <span class="kt">RawModule</span> <span class="o">=</span> <span class="n">currentModule</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">module</span><span class="k">:</span> <span class="kt">RawModule</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">module</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">throwException</span><span class="o">(</span>
      <span class="s">&#34;Error: Not in a UserModule. Likely cause: Missed Module() wrap, bare chisel API call, or attempting to construct hardware inside a BlackBox.&#34;</span>
    <span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">pushCommand</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Command</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">forcedUserModule</span><span class="o">.</span><span class="n">addCommand</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
    <span class="n">c</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">pushOp</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Data</span><span class="o">](</span><span class="n">cmd</span><span class="k">:</span> <span class="kt">DefPrim</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// Bind each element of the returned Data to being a Op
</span><span class="c1"></span>    <span class="n">cmd</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="nc">OpBinding</span><span class="o">(</span><span class="n">forcedUserModule</span><span class="o">))</span>
    <span class="n">pushCommand</span><span class="o">(</span><span class="n">cmd</span><span class="o">).</span><span class="n">id</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>抛出异常定义在 <code>Error.scala</code> 里，专门用于 <strong>ChiselException</strong> 相关的异常。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Error.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">object</span> <span class="nc">throwException</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=</span> <span class="kc">null</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">ChiselException</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>OpBinding</code> 运算结果的绑定类型是 <code>TopBinding</code> 的子类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Binding.scala
</span><span class="c1"></span><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ReadOnlyBinding</span> <span class="k">extends</span> <span class="nc">TopBinding</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">OpBinding</span><span class="o">(</span><span class="n">enclosure</span><span class="k">:</span> <span class="kt">RawModule</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ConstrainedBinding</span> <span class="k">with</span> <span class="nc">ReadOnlyBinding</span></code></pre></td></tr></table>
</div>
</div>
<p><code>RawModule</code> 模块的命令列表 <code>_commands</code>， 添加命令的方法 <code>addCommand</code> 和获取命令的方法 <code>getCommands</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/RawModule.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>

<span class="k">import</span> <span class="nn">chisel3.internal._</span>
<span class="k">import</span> <span class="nn">chisel3.internal.firrtl._</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">RawModule</span> <span class="k">extends</span> <span class="nc">BaseModule</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">_commands</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Command</span><span class="o">]()</span>
  <span class="k">def</span> <span class="n">addCommand</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Command</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(!</span><span class="nc">_closed</span><span class="o">,</span> <span class="s">&#34;Can&#39;t write to module after module close&#34;</span><span class="o">)</span>
    <span class="nc">_commands</span> <span class="o">+=</span> <span class="n">c</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">getCommands</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="nc">_closed</span><span class="o">,</span> <span class="s">&#34;Can&#39;t get commands before module close&#34;</span><span class="o">)</span>
    <span class="nc">_commands</span><span class="o">.</span><span class="n">toSeq</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>添加命令只能在例化模块的过程中调用，获取命令只能等到模块例化完毕后，在 <code>generateComponent</code> 方法里调用。</p>

<h3 id="connect-命令">Connect 命令</h3>

<p><code>Connect</code> 连接命令对应的是 <strong>Verilog</strong> 的赋值语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Data</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">connect</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Data</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">requireIsHardware</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&#34;data to be connected&#34;</span><span class="o">)</span>
    <span class="n">requireIsHardware</span><span class="o">(</span><span class="n">that</span><span class="o">,</span> <span class="s">&#34;data to be connected&#34;</span><span class="o">)</span>
    <span class="k">this</span><span class="o">.</span><span class="n">topBinding</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="k">_:</span> <span class="kt">ReadOnlyBinding</span> <span class="o">=&gt;</span> <span class="n">throwException</span><span class="o">(</span><span class="s">s&#34;Cannot reassign to read-only </span><span class="si">$this</span><span class="s">&#34;</span><span class="o">)</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>  <span class="c1">// fine
</span><span class="c1"></span>    <span class="o">}</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="nc">MonoConnect</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">that</span><span class="o">,</span> <span class="nc">Builder</span><span class="o">.</span><span class="n">referenceUserModule</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">MonoConnectException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">throwException</span><span class="o">(</span>
          <span class="s">s&#34;Connection between sink (</span><span class="si">$this</span><span class="s">) and source (</span><span class="si">$that</span><span class="s">) failed @</span><span class="si">$message</span><span class="s">&#34;</span>
        <span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def connect</code> 方法要求连接的两边都是可综合的硬件类型。在目前这个二选一的多路选择器里，涉及到连接的只有把位运算结果赋值给输出端口，位运算结果是 <code>OpBinding</code>，端口都是 <code>PortBinding</code>，都是硬件类型，符合条件。</p>

<p><code>connect</code> 方法的左侧（也就是调用该方法的对象）不能是 <code>ReadOnlyBinding</code> 的类型，比如这里的位运算结果，只能放在右侧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Data</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">topBinding</span><span class="k">:</span> <span class="kt">TopBinding</span> <span class="o">=</span> <span class="n">topBindingOpt</span><span class="o">.</span><span class="n">get</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def topBinding</code> 只是获取了 <code>topBindingOpt</code> 的 <code>Option</code> 值。</p>

<p><code>MonoConnect.connected</code> 方法的参数除了左/右值，还需要 <code>Builder</code> 的当前模块 <code>Builder.referenceUserModule</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Builder</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">referenceUserModule</span><span class="k">:</span> <span class="kt">RawModule</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">currentModule</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">module</span><span class="k">:</span> <span class="kt">RawModule</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">module</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">throwException</span><span class="o">(</span>
        <span class="s">&#34;Error: Not in a RawModule. Likely cause: Missed Module() wrap, bare chisel API call, or attempting to construct hardware inside a BlackBox.&#34;</span>
      <span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>referenceUserModule</code> 确保当前的模块类型是 <code>RawModule</code> 或是其子类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ touch chiselFrontend/src/internal/MonoConnect.scala</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/MonoConnect.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">chisel3.internal</span>

<span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">object</span> <span class="nc">MonoConnect</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nc">UnwritableSinkException</span> <span class="k">=</span>
    <span class="nc">MonoConnectException</span><span class="o">(</span><span class="s">&#34;: Sink is unwriteable by current module.&#34;</span><span class="o">)</span>
  <span class="k">def</span> <span class="nc">UnknownRelationException</span> <span class="k">=</span>
    <span class="nc">MonoConnectException</span><span class="o">(</span><span class="s">&#34;: Sink or source unavailable to current module.&#34;</span><span class="o">)</span>
  <span class="k">def</span> <span class="nc">MismatchedException</span><span class="o">(</span><span class="n">sink</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">source</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">MonoConnectException</span><span class="o">(</span><span class="s">s&#34;: Sink (</span><span class="si">$sink</span><span class="s">) and Source (</span><span class="si">$source</span><span class="s">) have different types.&#34;</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Sink</code> 直译是水槽， <code>Source</code> 是水源。按照水源流向水槽来理解，<code>Sink</code> 相当于赋值语句的左值，<code>Source</code> 相当于赋值语句的右值。</p>

<p>这里定义了三种错误类型：左值不可被赋值 <code>UnwritableSinkException</code>、当前模块的左/右值不可用 <code>UnknownRelationException</code> 和左/右值的类型不同 <code>MismatchedException</code> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/package.scala
</span><span class="c1"></span><span class="k">package</span> <span class="nn">object</span> <span class="n">chisel3</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">MonoConnectException</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ChiselException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>MonoConnectException</code> 继承了 <code>ChiselException</code>，作为 <strong>Chisel</strong> 异常的一种。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/MonoConnect.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">chisel3._</span>

<span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">object</span> <span class="nc">MonoConnect</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">connect</span><span class="o">(</span>
    <span class="n">sink</span><span class="k">:</span> <span class="kt">Data</span><span class="o">,</span>
    <span class="n">source</span><span class="k">:</span> <span class="kt">Data</span><span class="o">,</span>
    <span class="n">context_mod</span><span class="k">:</span> <span class="kt">RawModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="o">(</span><span class="n">sink</span><span class="o">,</span> <span class="n">source</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">sink_e</span><span class="k">:</span> <span class="kt">UInt</span><span class="o">,</span> <span class="n">source_e</span><span class="k">:</span> <span class="kt">UInt</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">elemConnect</span><span class="o">(</span><span class="n">sink_e</span><span class="o">,</span> <span class="n">source_e</span><span class="o">,</span> <span class="n">context_mod</span><span class="o">)</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">sink</span><span class="o">,</span> <span class="n">source</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="nc">MismatchedException</span><span class="o">(</span><span class="n">sink</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">source</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def connect</code> 方法这里只检查了左/右值的类型是否相同，然后调用 <code>elemConnect</code> 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/MonoConnect.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">object</span> <span class="nc">MonoConnect</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">elemConnect</span><span class="o">(</span><span class="n">sink</span><span class="k">:</span> <span class="kt">Element</span><span class="o">,</span> <span class="n">source</span><span class="k">:</span> <span class="kt">Element</span><span class="o">,</span> <span class="n">context_mod</span><span class="k">:</span> <span class="kt">RawModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">BindingDirection.</span><span class="o">{</span><span class="nc">Internal</span><span class="o">,</span> <span class="nc">Input</span><span class="o">,</span> <span class="nc">Output</span><span class="o">}</span>
    <span class="k">val</span> <span class="n">sink_mod</span><span class="k">:</span> <span class="kt">BaseModule</span>   <span class="o">=</span> <span class="n">sink</span><span class="o">.</span><span class="n">topBinding</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="k">throw</span> <span class="nc">UnwritableSinkException</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">source_mod</span><span class="k">:</span> <span class="kt">BaseModule</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">topBinding</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">context_mod</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">sink_direction</span> <span class="k">=</span> <span class="nc">BindingDirection</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">sink</span><span class="o">.</span><span class="n">topBinding</span><span class="o">,</span> <span class="n">sink</span><span class="o">.</span><span class="n">direction</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">source_direction</span> <span class="k">=</span> <span class="nc">BindingDirection</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">source</span><span class="o">.</span><span class="n">topBinding</span><span class="o">,</span> <span class="n">source</span><span class="o">.</span><span class="n">direction</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>如果找不到 <code>sink</code> 所在的模块，就无法赋值给左值，抛出 <code>UnwritableSinkException</code> 异常。找不到 <code>source</code> 所在的模块则认为是在当前模块下，比如字面量 <code>literal</code>，这里先不细究。</p>

<p><code>BindingDirection.from</code> 方法是把数据最终解析后的实际方向转换成绑定方向，规则如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Binding.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BindingDirection</span>
<span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">object</span> <span class="nc">BindingDirection</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Internal</span> <span class="k">extends</span> <span class="nc">BindingDirection</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Output</span> <span class="k">extends</span> <span class="nc">BindingDirection</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Input</span> <span class="k">extends</span> <span class="nc">BindingDirection</span>

  <span class="k">def</span> <span class="n">from</span><span class="o">(</span><span class="n">binding</span><span class="k">:</span> <span class="kt">TopBinding</span><span class="o">,</span> <span class="n">direction</span><span class="k">:</span> <span class="kt">ActualDirection</span><span class="o">)</span><span class="k">:</span> <span class="kt">BindingDirection</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">binding</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">PortBinding</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">direction</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">ActualDirection</span><span class="o">.</span><span class="nc">Output</span> <span class="k">=&gt;</span> <span class="nc">Output</span>
        <span class="k">case</span> <span class="nc">ActualDirection</span><span class="o">.</span><span class="nc">Input</span> <span class="k">=&gt;</span> <span class="nc">Input</span>
        <span class="k">case</span> <span class="n">dir</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">s&#34;Unexpected port element direction &#39;</span><span class="si">$dir</span><span class="s">&#39;&#34;</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Internal</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>绑定方向只针对于 <code>Element</code> 元素，且只用在绑定规则里（也就是这里的连接规则）。</p>

<p>绑定方向有三种：</p>

<ol>
<li>内部使用 <code>Internal</code>：比如 <code>wire</code> 或是其他内部类型；</li>
<li>输出类型 <code>Output</code>：模块的输出端口；</li>
<li>输入类型 <code>Input</code>：模块的输入端口。</li>
</ol>

<p><code>def from</code> 方法是根据一个 <code>Element</code> 类型数据的绑定类型和最终确定的实际方向得到的绑定方向。如果是端口绑定类型，实际方向的输入/输出就对应绑定方向的输入/输出。其他的绑定类型都是内部使用。</p>

<p>目前的二选一多路选择器例子只有一个模块，因此左/右值所在的模块就是当前模块。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/MonoConnect.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">object</span> <span class="nc">MonoConnect</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">elemConnect</span><span class="o">(</span><span class="n">sink</span><span class="k">:</span> <span class="kt">Element</span><span class="o">,</span> <span class="n">source</span><span class="k">:</span> <span class="kt">Element</span><span class="o">,</span> <span class="n">context_mod</span><span class="k">:</span> <span class="kt">RawModule</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="c1">// CASE: Context is same module that both left node and right node are in
</span><span class="c1"></span>    <span class="k">if</span><span class="o">(</span> <span class="o">(</span><span class="n">context_mod</span> <span class="o">==</span> <span class="n">sink_mod</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">context_mod</span> <span class="o">==</span> <span class="n">source_mod</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
      <span class="o">((</span><span class="n">sink_direction</span><span class="o">,</span> <span class="n">source_direction</span><span class="o">)</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="c1">//    SINK          SOURCE
</span><span class="c1"></span>        <span class="c1">//    CURRENT MOD   CURRENT MOD
</span><span class="c1"></span>        <span class="k">case</span> <span class="o">(</span><span class="nc">Output</span><span class="o">,</span>       <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">issueConnect</span><span class="o">(</span><span class="n">sink</span><span class="o">,</span> <span class="n">source</span><span class="o">)</span>
        <span class="k">case</span> <span class="o">(</span><span class="nc">Internal</span><span class="o">,</span>     <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">issueConnect</span><span class="o">(</span><span class="n">sink</span><span class="o">,</span> <span class="n">source</span><span class="o">)</span>
        <span class="k">case</span> <span class="o">(</span><span class="nc">Input</span><span class="o">,</span>        <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="nc">UnwritableSinkException</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="k">throw</span> <span class="nc">UnknownRelationException</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>输出端口和内部使用的数据都是可以当作左值被赋值，只有输入端口不能被赋值。</p>

<p>当所有连接相关的检查通过之后，调用 <code>issueConnect</code> 方法生成连接命令，添加到模块的命令列表里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/MonoConnect.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">chisel3.internal.Builder.pushCommand</span>
<span class="k">import</span> <span class="nn">chisel3.internal.firrtl.Connect</span>

<span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">object</span> <span class="nc">MonoConnect</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">issueConnect</span><span class="o">(</span><span class="n">sink</span><span class="k">:</span> <span class="kt">Element</span><span class="o">,</span> <span class="n">source</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">source</span><span class="o">.</span><span class="n">topBinding</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">pushCommand</span><span class="o">(</span><span class="nc">Connect</span><span class="o">(</span><span class="n">sink</span><span class="o">.</span><span class="n">lref</span><span class="o">,</span> <span class="n">source</span><span class="o">.</span><span class="n">ref</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Connect</code> 命令存放了左值 <code>loc: Node</code> 必须是 <code>Node</code> 节点参数类型，右值 <code>exp: Arg</code> 是 <code>Arg</code> 基本参数类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Connect</span><span class="o">(</span><span class="n">loc</span><span class="k">:</span> <span class="kt">Node</span><span class="o">,</span> <span class="n">exp</span><span class="k">:</span> <span class="kt">Arg</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Command</span></code></pre></td></tr></table>
</div>
</div>
<p><code>lref</code> 跟 <code>ref</code> 有所不同，<code>lref</code> 要求不能是 <code>ReadOnlyBinding</code> 只读绑定类型（只读的当然不能被赋值啦）， <code>ref</code> 要求不能是字面量绑定类型 <code>LitBinding</code> （这里不细究）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Data.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Data</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">lref</span><span class="k">:</span> <span class="kt">Node</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">requireIsHardware</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
    <span class="n">topBindingOpt</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">binding</span><span class="k">:</span> <span class="kt">ReadOnlyBinding</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">throwException</span><span class="o">(</span><span class="s">s&#34;internal error: attempted to generate LHS ref to ReadOnlyBinding </span><span class="si">$binding</span><span class="s">&#34;</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">binding</span><span class="k">:</span> <span class="kt">TopBinding</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Node</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">opt</span> <span class="k">=&gt;</span> <span class="n">throwException</span><span class="o">(</span><span class="s">s&#34;internal error: unknown binding </span><span class="si">$opt</span><span class="s"> in generating LHS ref&#34;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="命名空间">命名空间</h2>

<p>命名空间 <strong>Namespace</strong> 内部使用可变的数据结构 <code>HashMap[String, Long]</code>。命名用的是字符串类型，作为哈希的键；名字出现的次数是长整型，作为哈希的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">class</span> <span class="nc">Namespace</span><span class="o">(</span><span class="n">keywords</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">names</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">]()</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">keyword</span> <span class="k">&lt;-</span> <span class="n">keywords</span><span class="o">)</span>
    <span class="n">names</span><span class="o">(</span><span class="n">keyword</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>关键词（<code>keyword</code>）是命名空间的保留字，不能再用来命名。因此命名空间初始化的时候需要把关键词加上， 赋值为 <code>1</code> 表示关键词出现了一次。 <code>Set[String]</code> 集合类型保证了关键词不会重复出现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">class</span> <span class="nc">Namespace</span><span class="o">(</span><span class="n">keywords</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">contains</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>内部的数据结构 <code>private val names</code> 是私有成员，外部不可访问，因此用一个同名方法 <code>def contains</code> 包装一层。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">class</span> <span class="nc">Namespace</span><span class="o">(</span><span class="n">keywords</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">name</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="n">contains</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">name</span><span class="o">(</span><span class="n">rename</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">names</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>
      <span class="n">elem</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>传递一个你想命名的名字给 <code>def name</code> 方法，1）如果命名空间里不存在，则添加到命名空间并标记为 <code>1</code> （出现了 1 次）；2）如果命名空间存在，那么就在该名字后面加上出现的第几次作为后缀。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">class</span> <span class="nc">Namespace</span><span class="o">(</span><span class="n">keywords</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">rename</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">index</span> <span class="k">=</span> <span class="n">names</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">tryName</span> <span class="k">=</span> <span class="s">s&#34;</span><span class="si">${</span><span class="n">n</span><span class="si">}</span><span class="s">_</span><span class="si">${</span><span class="n">index</span><span class="si">}</span><span class="s">&#34;</span>
    <span class="n">names</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="n">contains</span> <span class="n">tryName</span><span class="o">)</span> <span class="n">rename</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">else</span> <span class="n">tryName</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def rename</code> 方法是私有的，只有当 <code>def name</code> 方法里发现命名空间存在该名字的时候才被调用。先拿到该名字在命名空间出现的次数，作为后缀，然后更新出现的次数。如果加了后缀还是有冲突，那么再继续加后缀。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">object</span> <span class="nc">Namespace</span> <span class="o">{</span>
  <span class="cm">/** Constructs an empty Namespace */</span>
  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Namespace</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Namespace</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>单例对象 <code>Namespace</code> 只是用 <code>def empty</code> 方法来方便创建一个没有关键字，空的命名空间。跟自己写一个<code>new Namespace(Set.empty[String])</code>等价。</p>

<h2 id="生成-verilog-模块">生成 Verilog 模块</h2>

<p><code>generateComponent</code> 方法根据例化用户定义的模块收集到的信息生成 <strong>Verilog</strong> 模块。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/RawModule.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">RawModule</span> <span class="k">extends</span> <span class="nc">BaseModule</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">generateComponent</span><span class="o">()</span><span class="k">:</span> <span class="kt">Component</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">names</span> <span class="k">=</span> <span class="n">nameIds</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RawModule</span><span class="o">])</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>val names</code> 存放的是<code>nameIds</code> 先创建的哈希表<code>HashMap</code>，存放用户定义的<strong>Chisel</strong> 模块（这里的例子是 <code>class Mux2</code>）里的每个 <strong>Chisel</strong> 元素（ <code>HasId</code> 的子类型）及其对应的名字。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">scala.collection.mutable.</span><span class="o">{</span><span class="nc">ArrayBuffer</span><span class="o">,</span> <span class="nc">HashMap</span><span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">protected</span> <span class="k">def</span> <span class="n">nameIds</span><span class="o">(</span><span class="n">rootClass</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">HashMap</span><span class="o">[</span><span class="kt">HasId</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">names</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">HasId</span>, <span class="kt">String</span><span class="o">]()</span>
    <span class="k">def</span> <span class="n">name</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">HasId</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">names</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">names</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">m</span> <span class="k">&lt;-</span> <span class="n">getPublicFields</span><span class="o">(</span><span class="n">rootClass</span><span class="o">))</span> <span class="o">{</span>
      <span class="nc">Builder</span><span class="o">.</span><span class="n">nameRecursively</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="n">getName</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">),</span> <span class="n">name</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">names</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def nameIds</code> 方法是定义在 <code>BaseModule</code> 里的。</p>

<p><code>val names</code> 是方法内部的数据结构，<code>def name</code> 方法往里添加 <strong>Chisel</strong> 元素和对应名字的键值对，确保不会重复。</p>

<p><code>for (m &lt;- getPublicFields(rootClass)) {...}</code> 循环是迭代用户继承 <code>rootClass</code> （这里是 <code>RawModule</code>）自定义模块（这里是 <code>Mux2</code>）里的每一个公共数据值 <code>val</code>，传给 <code>Builder.nameRecursively</code> 方法筛选出哪些 <code>val</code> 是定义了 <strong>Chisel</strong> 元素，然后给它们命名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">trait</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">getPublicFields</span><span class="o">(</span><span class="n">rootClass</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">java.lang.reflect.Method</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="c1">// Suggest names to nodes using runtime reflection
</span><span class="c1"></span>    <span class="k">def</span> <span class="n">getValNames</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">rootClass</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">()</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">getValNames</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">getSuperclass</span><span class="o">)</span> <span class="o">++</span> <span class="n">c</span><span class="o">.</span><span class="n">getDeclaredFields</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">getName</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">val</span> <span class="n">valNames</span> <span class="k">=</span> <span class="n">getValNames</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">getClass</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">isPublicVal</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">java.lang.reflect.Method</span><span class="o">)</span> <span class="k">=</span>
      <span class="n">m</span><span class="o">.</span><span class="n">getParameterTypes</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">&amp;&amp;</span> <span class="n">valNames</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="n">getName</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">m</span><span class="o">.</span><span class="n">getDeclaringClass</span><span class="o">.</span><span class="n">isAssignableFrom</span><span class="o">(</span><span class="n">rootClass</span><span class="o">)</span>

    <span class="k">this</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getMethods</span><span class="o">.</span><span class="n">sortWith</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">getName</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">.</span><span class="n">getName</span><span class="o">).</span><span class="n">filter</span><span class="o">(</span><span class="n">isPublicVal</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>getValNames(this.getClass)</code> 是从当前类遍历到根类 <code>rootClass</code> 之前，不包含根类（这里是 <code>RawModule</code> ）的所有声明过的变量名字，放在 <code>valNames</code> 里。</p>

<p><code>def isPublicVal</code> 筛选出公共变量的方法是根据三个条件：</p>

<ol>
<li><code>getParameterTypes.isEmpty</code> 没有参数的，排除掉带参数的方法；</li>
<li><code>valNames.contains</code> 名字是限定在刚才获取的 <code>valNames</code> 范围里的；</li>
<li><code>!m.getDeclaringClass.isAssignableFrom</code> 是不可以被赋值的，排除 <code>var</code>。</li>
</ol>

<p><code>this.getClass.getMethods</code> 是获得该类以及它继承的所有父类定义过的方法（<code>val</code> 和 <code>var</code>包括在内），然后通过 <code>isPublicVal</code> 方法筛选出从根类（这里是 <code>RawModule</code>）之后的子类定义过的公共 <code>val</code> 声明的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Builder</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">nameRecursively</span><span class="o">(</span><span class="n">prefix</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">nameMe</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">namer</span><span class="k">:</span> <span class="o">(</span><span class="kt">HasId</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">nameMe</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">HasId</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">namer</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">prefix</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">elt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">nameRecursively</span><span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">elt</span><span class="o">,</span> <span class="n">namer</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="n">m</span> <span class="n">foreach</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">nameRecursively</span><span class="o">(</span><span class="s">s&#34;</span><span class="si">${</span><span class="n">k</span><span class="si">}</span><span class="s">&#34;</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">namer</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">iter</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="k">_</span><span class="o">])</span> <span class="k">if</span> <span class="n">iter</span><span class="o">.</span><span class="n">hasDefiniteSize</span> <span class="k">=&gt;</span>
      <span class="k">for</span> <span class="o">((</span><span class="n">elt</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">iter</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nameRecursively</span><span class="o">(</span><span class="s">s&#34;</span><span class="si">${</span><span class="n">prefix</span><span class="si">}</span><span class="s">_</span><span class="si">${</span><span class="n">i</span><span class="si">}</span><span class="s">&#34;</span><span class="o">,</span> <span class="n">elt</span><span class="o">,</span> <span class="n">namer</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="c1">// Do nothing
</span><span class="c1"></span>  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def nameRecursively</code> 结合调用它传递的参数来看，分别是 <code>val</code> 声明的名字， <code>val</code> 执行后的值和往<code>names</code>里添加 <strong>Chisel</strong> 及其对应的名字键值对的 <code>name</code> 方法。</p>

<p><code>case (id: HasId)</code> 如果是 <strong>Chisel</strong> 类型的数据，比如 <code>val foo = UInt(3.W)</code>，<code>UInt</code> 是 <code>HasId</code> 的子类满足条件，然后执行 <code>namer(id, prefix)</code> 把 <strong>Chisel</strong> 元素 <code>UInt(3.W)</code>（<code>id</code>）和对应的名字 <code>foo</code>（<code>prefix</code>）键值对存到之前声明的 <code>names</code> 数据结构里。</p>

<p><code>case Some(elt)</code> 是对应 <code>val foo = Some(UInt(3.W))</code> 这种情况。</p>

<p><code>case m: Map[_,_]</code> 是咧威新增的，支持 <code>val fooMap = Map(&quot;foo&quot; -&gt; UInt(3.W))</code> 这种情况。</p>

<p><code>case  (iter: Iterable[_]) if iter.hasDefiniteSize</code> 支持的是 <code>val fooList = List(UInt(3.W))</code> 这种情况。</p>

<p>其他情况则忽略。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/RawModule.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">scala.collection.mutable.</span><span class="o">{</span><span class="nc">ArrayBuffer</span><span class="o">,</span> <span class="nc">HashMap</span><span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">RawModule</span> <span class="k">extends</span> <span class="nc">BaseModule</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">namePorts</span><span class="o">(</span><span class="n">names</span><span class="k">:</span> <span class="kt">HashMap</span><span class="o">[</span><span class="kt">HasId</span>, <span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">port</span> <span class="k">&lt;-</span> <span class="n">getModulePorts</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">port</span><span class="o">.</span><span class="n">suggestedName</span><span class="o">.</span><span class="n">orElse</span><span class="o">(</span><span class="n">names</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">port</span><span class="o">))</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="k">if</span> <span class="o">(</span><span class="nc">_namespace</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">throwException</span><span class="o">(</span><span class="s">s&#34;&#34;&#34;Unable to name port </span><span class="si">$port</span><span class="s"> to &#34;</span><span class="si">$name</span><span class="s">&#34; in </span><span class="si">$this</span><span class="s">,&#34;&#34;&#34;</span> <span class="o">+</span>
              <span class="s">&#34; name is already taken by another port!&#34;</span><span class="o">)</span>
          <span class="o">}</span>
          <span class="n">port</span><span class="o">.</span><span class="n">setRef</span><span class="o">(</span><span class="nc">ModuleIO</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="nc">_namespace</span><span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="n">name</span><span class="o">)))</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">throwException</span><span class="o">(</span><span class="s">s&#34;Unable to name port </span><span class="si">$port</span><span class="s"> in </span><span class="si">$this</span><span class="s">, &#34;</span> <span class="o">+</span>
          <span class="s">&#34;try making it a public field of the Module&#34;</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">generateComponent</span><span class="o">()</span><span class="k">:</span> <span class="kt">Component</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="n">namePorts</span><span class="o">(</span><span class="n">names</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>port.suggestedName.orElse(names.get(port))</code> 如果用户定义了名字（<code>suggestedName</code>）则使用自定义的，否则才去用代码里写的变量名。</p>

<p><code>namePorts</code> 方法给模块的端口绑定名字 <code>port.setRef(ModuleIO(this, _namespace.name(name)))</code>。调用命名空间的 <code>name</code> 方法是确保不会起重复的名字。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">ModuleIO</span><span class="o">(</span><span class="n">mod</span><span class="k">:</span> <span class="kt">BaseModule</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Arg</span></code></pre></td></tr></table>
</div>
</div>
<p><code>ModuleIO</code> 存放的信息是端口所在的模块和它的名字。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">val</span> <span class="nc">_namespace</span> <span class="k">=</span> <span class="nc">Namespace</span><span class="o">.</span><span class="n">empty</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里的 <code>_namespace</code> 模块自己的命名空间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/RawModule.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">RawModule</span> <span class="k">extends</span> <span class="nc">BaseModule</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">generateComponent</span><span class="o">()</span><span class="k">:</span> <span class="kt">Component</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="k">for</span> <span class="o">((</span><span class="n">node</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">node</span><span class="o">.</span><span class="n">suggestName</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>suggestName</code> 只绑定一次，多次调用会忽略。 这里是确保所有 <strong>Chisel</strong> 元素都有自定义的名字，如果用户没有定义则用代码里声明的名字，定义了不会被覆盖。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/RawModule.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">RawModule</span> <span class="k">extends</span> <span class="nc">BaseModule</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">generateComponent</span><span class="o">()</span><span class="k">:</span> <span class="kt">Component</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="c1">// All suggestions are in, force names to every node.
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="n">id</span> <span class="k">&lt;-</span> <span class="n">getIds</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">id</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">id</span><span class="k">:</span> <span class="kt">BaseModule</span> <span class="o">=&gt;</span> <span class="n">id</span><span class="o">.</span><span class="n">forceName</span><span class="o">(</span><span class="n">default</span><span class="k">=</span><span class="n">id</span><span class="o">.</span><span class="n">desiredName</span><span class="o">,</span> <span class="nc">_namespace</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Data</span>  <span class="o">=&gt;</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="n">isSynthesizable</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">id</span><span class="o">.</span><span class="n">topBinding</span> <span class="k">match</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">OpBinding</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">|</span> <span class="nc">PortBinding</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="n">id</span><span class="o">.</span><span class="n">forceName</span><span class="o">(</span><span class="n">default</span><span class="o">=</span><span class="s">&#34;_T&#34;</span><span class="o">,</span> <span class="nc">_namespace</span><span class="o">)</span>
              <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>  <span class="c1">// don&#39;t name literals
</span><span class="c1"></span>            <span class="o">}</span>
          <span class="o">}</span> <span class="c1">// else, don&#39;t name unbound types
</span><span class="c1"></span>      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>getIds</code> 是获取当前模块里所有的 <strong>Chisel</strong> 元素。</p>

<p><code>case id: BaseModule</code> 如果是 <strong>Verilog</strong> 模块类型的，调用自身的 <code>forceName</code> 方法起 <code>desiredName</code> 定义的名字，确保在 <code>_namespace</code>命名空间里不重名。</p>

<p><code>case id: Data</code> 是给可综合的硬件类型起名字，这里只有位运算的结果 <code>OpBinding</code> 和端口 <code>PortBinding</code> 两种。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">val</span> <span class="nc">_ids</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">HasId</span><span class="o">]()</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">addId</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">HasId</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(!</span><span class="nc">_closed</span><span class="o">,</span> <span class="s">&#34;Can&#39;t write to module after module close&#34;</span><span class="o">)</span>
    <span class="nc">_ids</span> <span class="o">+=</span> <span class="n">d</span>
  <span class="o">}</span>
  <span class="k">protected</span> <span class="k">def</span> <span class="n">getIds</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="nc">_closed</span><span class="o">,</span> <span class="s">&#34;Can&#39;t get ids before module close&#34;</span><span class="o">)</span>
    <span class="nc">_ids</span><span class="o">.</span><span class="n">toSeq</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>Verilog</strong> 模块里定义的 <strong>Chisel</strong> 元素是收集在 <code>_ids</code> 列表里的。只有在模块没有关闭之前可以添加 <code>addId</code>，在模块关闭后（也就是调用 <code>generateComponent</code> 方法时）获取 <code>getIds</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">trait</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">val</span> <span class="nc">_parent</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">BaseModule</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Builder</span><span class="o">.</span><span class="n">currentModule</span>
  <span class="nc">_parent</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">addId</span><span class="o">(</span><span class="k">this</span><span class="o">))</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>每个 <strong>Chisel</strong> 元素在例化的时候都会自动添加到当前的模块。</p>

<p><strong>注意</strong>： <strong>Mux2</strong> 模块也是 <strong>HasId</strong>，也会自动添加到当前模块。但由于它是最顶层的 <strong>HasId</strong>，此时的 <code>Builder.currentModule</code> 还是初始值 <code>None</code>。 <code>_parent.foreach</code> 就派上用场了。 <code>foreach</code> 这里不是迭代的意思，而是当遇到 <code>None</code> 的时候不执行。因此 <strong>Mux2</strong> 顶层模块不会被添加。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">trait</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">chisel3</span><span class="o">]</span> <span class="k">def</span> <span class="n">forceName</span><span class="o">(</span><span class="n">default</span><span class="k">:</span> <span class="o">=&gt;</span><span class="nc">String</span><span class="o">,</span> <span class="n">namespace</span><span class="k">:</span> <span class="kt">Namespace</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="k">if</span><span class="o">(</span><span class="nc">_ref</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">candidate_name</span> <span class="k">=</span> <span class="n">suggested_name</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">default</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">available_name</span> <span class="k">=</span> <span class="n">namespace</span><span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="n">candidate_name</span><span class="o">)</span>
      <span class="n">setRef</span><span class="o">(</span><span class="nc">Ref</span><span class="o">(</span><span class="n">available_name</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>forceName</code> 会先看 <code>suggested_name</code> 有没有定义，没有定义则用默认值 <code>default</code>，同时调用命名空间的 <code>name</code> 方法确保不重名。</p>

<p><code>setRef</code> 方法只是为了起名字。</p>

<p><strong>注意</strong>：回想下前面的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala">  <span class="k">for</span> <span class="o">(</span><span class="n">id</span> <span class="k">&lt;-</span> <span class="n">getIds</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">id</span> <span class="k">match</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">case</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Data</span>  <span class="o">=&gt;</span>
              <span class="o">...</span>
              <span class="k">case</span> <span class="nc">OpBinding</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">|</span> <span class="nc">PortBinding</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="n">id</span><span class="o">.</span><span class="n">forceName</span><span class="o">(</span><span class="n">default</span><span class="o">=</span><span class="s">&#34;_T&#34;</span><span class="o">,</span> <span class="nc">_namespace</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<p>以现在的二选一多路选择器为例 <code>io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0)</code> 这里的位运算<code>(io.sel &amp; io.in1)</code>会产生一个 <strong>Chisel</strong> <code>Data</code> 存放结果，但是它又不是用 <code>val</code> 独立声明的，所以 <code>suggestedName</code> 是没有定义的，会采用默认值 <code>default=&quot;_T&quot;</code>命名。当出现多个这种中间变量时，根据命名空间重名加出现次数作为后缀的解决办法，就会生成 <code>_T_1</code>、 <code>_T_2</code>这种名字。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">BaseModule</span> <span class="k">extends</span> <span class="nc">HasId</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="cm">/** Desired name of this module. Override this to give this module a custom, perhaps parametric,
</span><span class="cm">    * name.
</span><span class="cm">    */</span>
  <span class="k">def</span> <span class="n">desiredName</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="sc">&#39;.&#39;</span><span class="o">).</span><span class="n">last</span>

  <span class="k">final</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="n">desiredName</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>desiredName</code> 默认是声明的模块类的名字，比如 <code>class Mux2</code> 的名字是 <code>Mux2</code>。如果想改变模块的名字为 <code>Mux2Foo</code>，重载 <code>desiredName</code> 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Mux2</span> <span class="k">extends</span> <span class="nc">RawModule</span> <span class="o">{</span>
  <span class="k">override</span> <span class="n">desiredName</span> <span class="k">=</span> <span class="s">&#34;Mux2Foo&#34;</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/RawModule.scala
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">RawModule</span> <span class="k">extends</span> <span class="nc">BaseModule</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">generateComponent</span><span class="o">()</span><span class="k">:</span> <span class="kt">Component</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">val</span> <span class="n">firrtlPorts</span> <span class="k">=</span> <span class="n">getModulePorts</span> <span class="n">map</span> <span class="o">{</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Data</span> <span class="o">=&gt;</span>
      <span class="k">val</span> <span class="n">direction</span> <span class="k">=</span> <span class="n">port</span><span class="o">.</span><span class="n">specifiedDirection</span>
      <span class="nc">Port</span><span class="o">(</span><span class="n">port</span><span class="o">,</span> <span class="n">direction</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="nc">DefModule</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">firrtlPorts</span><span class="o">,</span> <span class="n">getCommands</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>getModulePorts</code> 获取当前模块的端口列表，转成端口 <strong>IR</strong> <code>Port(port, direction)</code>。</p>

<p><strong>Verilog</strong> 模块 <strong>IR</strong> 的信息包括该模块自身 <code>this</code>、名字 <code>name</code>、端口 <strong>IR</strong> 列表和命令列表（命令对应 <strong>Verilog</strong> 的语句）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/IR.scala
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Port</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Data</span><span class="o">,</span> <span class="n">dir</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">)</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Component</span> <span class="k">extends</span> <span class="nc">Arg</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">id</span><span class="k">:</span> <span class="kt">BaseModule</span>
  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">def</span> <span class="n">ports</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Port</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">DefModule</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">RawModule</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">ports</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Port</span><span class="o">],</span> <span class="n">commands</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Command</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Component</span></code></pre></td></tr></table>
</div>
</div>
<p>端口 <strong>IR</strong> 包括端口数据和方向。</p>

<p><code>Component</code> 是所有 <strong>Verilog</strong> 模块类型的基类，包括模块自身，名字和端口。</p>

<p><code>DefModule</code> 比基类多了命令列表。还有其他的模块类型，比如 <strong>BlackBox</strong> 也是继承的 <code>Component</code> 基类，这里不细究。</p>

<h2 id="生成电路-ir">生成电路 IR</h2>

<p><code>object Module</code> 是负责生成 <strong>Verilog</strong> 模块 <strong>IR</strong>，并添加到 <strong>Builder</strong> 的全局 <strong>Verilog</strong> 模块列表里。</p>

<p><code>Builder.build</code> 是负责把 <strong>Verilog</strong> 模块列表生成整个电路 <strong>IR</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/Module.scala
</span><span class="c1"></span><span class="k">object</span> <span class="nc">Module</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">BaseModule</span><span class="o">](</span><span class="n">bc</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">module</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">bc</span>
    <span class="k">val</span> <span class="n">component</span> <span class="k">=</span> <span class="n">module</span><span class="o">.</span><span class="n">generateComponent</span><span class="o">()</span>
    <span class="nc">Builder</span><span class="o">.</span><span class="n">components</span> <span class="o">+=</span> <span class="n">component</span>
    <span class="n">module</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Module.apply</code> 调用参数传进来的模块 <code>generateComponent</code> 方法生成 <strong>Verilog</strong> 模块 <strong>IR</strong>，添加到 <code>Builder.components</code> 的模块列表里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/chiselFrontend/src/internal/Builder.scala
</span><span class="c1"></span><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>

<span class="k">object</span> <span class="nc">Builder</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">components</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">[</span><span class="kt">Component</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Component</span><span class="o">]()</span>
  <span class="k">def</span> <span class="n">globalNamespace</span><span class="k">:</span> <span class="kt">Namespace</span> <span class="o">=</span> <span class="nc">Namespace</span><span class="o">.</span><span class="n">empty</span>

  <span class="o">...</span>
  <span class="k">def</span> <span class="n">build</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">RawModule</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Circuit</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&#34;Elaborating design...&#34;</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">mod</span> <span class="k">=</span> <span class="n">f</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">forceName</span><span class="o">(</span><span class="n">mod</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">globalNamespace</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&#34;Done elaborating.&#34;</span><span class="o">)</span>

    <span class="o">(</span><span class="nc">Circuit</span><span class="o">(</span><span class="n">components</span><span class="o">.</span><span class="n">last</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">components</span><span class="o">),</span> <span class="n">mod</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Builder.build</code> 拿到的是经过了 <strong>Module()</strong> 后最顶层的模块。调用<code>forceName</code> 起名字，确保在 <code>Builder</code> 的全局命名空间里不重名。</p>

<p>电路 <strong>IR</strong> 的名字是最顶层（最后一个添加的，所以是列表的最后一个）模块的名字，它存放的信息是所有模块的 <strong>IR</strong>。</p>

<h1 id="解析-ir-生成-firrtl">解析 IR 生成 FIRRTL</h1>

<p><code>Emitter</code> 负责把电路 <strong>IR</strong> 生成 <strong>FIRRTL</strong> 字符串的形式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span><span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">()</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>val res</code> 可变的字符串构造器 <code>StringBuilder</code>。<code>def toString</code> 方法是生成最终的字符串。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span><span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">indentLevel</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">newline</span> <span class="k">=</span> <span class="s">&#34;\n&#34;</span> <span class="o">+</span> <span class="o">(</span><span class="s">&#34;  &#34;</span> <span class="o">*</span> <span class="n">indentLevel</span><span class="o">)</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">indent</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">indentLevel</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">unindent</span><span class="o">()</span> <span class="o">{</span> <span class="n">require</span><span class="o">(</span><span class="n">indentLevel</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span> <span class="n">indentLevel</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">}</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">withIndent</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="o">{</span> <span class="n">indent</span><span class="o">();</span> <span class="n">f</span><span class="o">;</span> <span class="n">unindent</span><span class="o">()</span> <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里先定义一些后续用到的变量和方法：</p>

<ul>
<li><code>indentLevel</code> 缩进层次记录当前的缩进是多少个空格，初始值为 0；</li>
<li><code>def newline</code> 方法除了换行还会加上缩进层次的空格；</li>
<li><code>indent</code> 和 <code>unindent</code> 分别是缩进层次加 1 和减 1；</li>
<li><code>withIndent</code> 是对应的一套缩进层次，方便构建一个作用域。</li>
</ul>

<p>都是方便创建缩进层次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span><span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="n">res</span> <span class="o">++=</span> <span class="s">s&#34;circuit </span><span class="si">${</span><span class="n">circuit</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> : &#34;</span>
  <span class="n">withIndent</span> <span class="o">{</span> <span class="n">circuit</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">++=</span> <span class="n">emit</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">}</span>
  <span class="n">res</span> <span class="o">++=</span> <span class="n">newline</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>先生成电路的名字，然后创建一级缩进的作用域，生成每一个模块，最后空一行结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span><span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">emit</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Component</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">sb</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
    <span class="n">sb</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">moduleDecl</span><span class="o">(</span><span class="n">m</span><span class="o">))</span>
    <span class="n">sb</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">moduleDefn</span><span class="o">(</span><span class="n">m</span><span class="o">))</span>
    <span class="n">sb</span><span class="o">.</span><span class="n">result</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>生成模块的 <code>emit(m: Component)</code>方法先生成模块的声明，然后才生成模块的定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span><span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">moduleDecl</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Component</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">id</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">RawModule</span> <span class="o">=&gt;</span> <span class="n">newline</span> <span class="o">+</span> <span class="s">s&#34;module </span><span class="si">${</span><span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> : &#34;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def moduleDecl(m: Component)</code> 方法生成 <strong>FIRRTL</strong> 模块的声明，<code>module 模块名字</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span><span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">moduleDefn</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Component</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">body</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
    <span class="n">withIndent</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">m</span><span class="o">.</span><span class="n">ports</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">portDef</span> <span class="k">=</span> <span class="n">m</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">mod</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=&gt;</span> <span class="n">emitPort</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="n">body</span> <span class="o">++=</span> <span class="n">newline</span> <span class="o">+</span> <span class="n">portDef</span>
      <span class="o">}</span>
      <span class="n">body</span> <span class="o">++=</span> <span class="n">newline</span>

      <span class="n">m</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">mod</span><span class="k">:</span> <span class="kt">DefModule</span> <span class="o">=&gt;</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">procMod</span> <span class="k">=</span> <span class="n">mod</span>
          <span class="k">for</span> <span class="o">(</span><span class="n">cmd</span> <span class="k">&lt;-</span> <span class="n">procMod</span><span class="o">.</span><span class="n">commands</span><span class="o">)</span> <span class="o">{</span> <span class="n">body</span> <span class="o">++=</span> <span class="n">newline</span> <span class="o">+</span> <span class="n">emit</span><span class="o">(</span><span class="n">cmd</span><span class="o">,</span> <span class="n">procMod</span><span class="o">)}</span>
        <span class="o">}</span>
      <span class="o">}</span>
      <span class="n">body</span> <span class="o">++=</span> <span class="n">newline</span>
    <span class="o">}</span>
    <span class="n">body</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def moduleDefn</code> 生成模块定义的方法，先生成一级缩进，作为模块内部作用域的缩进；再生成端口列表；最后生成命令列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span><span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">emitPort</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Port</span><span class="o">,</span> <span class="n">topDir</span><span class="k">:</span> <span class="kt">SpecifiedDirection</span><span class="o">=</span><span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">resolvedDir</span> <span class="k">=</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="n">fromParent</span><span class="o">(</span><span class="n">topDir</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="n">dir</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">dirString</span> <span class="k">=</span> <span class="n">resolvedDir</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span> <span class="o">|</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Output</span> <span class="k">=&gt;</span> <span class="s">&#34;output&#34;</span>
      <span class="k">case</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Flip</span> <span class="o">|</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Input</span> <span class="k">=&gt;</span> <span class="s">&#34;input&#34;</span>
    <span class="o">}</span>
    <span class="k">val</span> <span class="n">clearDir</span> <span class="k">=</span> <span class="n">resolvedDir</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Input</span> <span class="o">|</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Output</span> <span class="k">=&gt;</span> <span class="kc">true</span>
      <span class="k">case</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Unspecified</span> <span class="o">|</span> <span class="nc">SpecifiedDirection</span><span class="o">.</span><span class="nc">Flip</span> <span class="k">=&gt;</span> <span class="kc">false</span>
    <span class="o">}</span>
    <span class="s">s&#34;</span><span class="si">$dirString</span><span class="s"> </span><span class="si">${</span><span class="n">e</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">getRef</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> : </span><span class="si">${</span><span class="n">emitType</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">id</span><span class="o">,</span> <span class="n">clearDir</span><span class="o">)</span><span class="si">}</span><span class="s">&#34;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def emitPort</code> 生成端口的方法先确定端口的方向，然后通过 <code>id.getRef.name</code> 拿到端口的名字，最后调用 <code>emitType</code> 得到端口的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span><span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">emitType</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Data</span><span class="o">,</span> <span class="n">clearDir</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">d</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">d</span><span class="k">:</span> <span class="kt">UInt</span> <span class="o">=&gt;</span> <span class="s">s&#34;UInt</span><span class="si">${</span><span class="n">d</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s">&#34;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def emitType</code> 生成类型的方法，目前只有 <code>UInt</code> 类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// play-chisel/src/internal/firrtl/Emitter.scala
</span><span class="c1"></span><span class="k">private</span> <span class="k">class</span> <span class="nc">Emitter</span><span class="o">(</span><span class="n">circuit</span><span class="k">:</span> <span class="kt">Circuit</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">emit</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Command</span><span class="o">,</span> <span class="n">ctx</span><span class="k">:</span> <span class="kt">Component</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span> <span class="c1">// scalastyle:ignore cyclomatic.complexity
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">firrtlLine</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">DefPrim</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">s&#34;node </span><span class="si">${</span><span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> = </span><span class="si">${</span><span class="n">e</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s">(</span><span class="si">${</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">fullName</span><span class="o">(</span><span class="n">ctx</span><span class="o">)).</span><span class="n">mkString</span><span class="o">(</span><span class="s">&#34;, &#34;</span><span class="o">)</span><span class="si">}</span><span class="s">)&#34;</span>
      <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Connect</span> <span class="o">=&gt;</span> <span class="s">s&#34;</span><span class="si">${</span><span class="n">e</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">fullName</span><span class="o">(</span><span class="n">ctx</span><span class="o">)</span><span class="si">}</span><span class="s"> &lt;= </span><span class="si">${</span><span class="n">e</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">fullName</span><span class="o">(</span><span class="n">ctx</span><span class="o">)</span><span class="si">}</span><span class="s">&#34;</span>
    <span class="o">}</span>
    <span class="n">firrtlLine</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>def emit(e: Command, ctx: Component)</code> 方法生成 <strong>Verilog</strong> 语句。目前只有两种类型：</p>

<ul>
<li><code>DefPrim</code> 运算语句：作为 <strong>FIRRTL</strong> 的一个节点 <code>node 名字 = 运算类型的名字 参数列表</code></li>
<li><code>Connect</code> 赋值语句： <code>左值名字 &lt;= 右值表达式名字</code></li>
</ul>

<div class="admonition tip"><p class="admonition-title">源码03</p>
  

</div>

<p><a href="https://github.com/colin4124/play-chisel/tree/chap01-03">play-chisel/tree/chap01-03</a></p>

<h1 id="生成-verilog">生成 Verilog</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mill chisel3.run</code></pre></td></tr></table>
</div>
</div>
<p><a href="https://github.com/colin4124/chisel3-releases/releases/download/firrtl-1.2.0/firrtl-1.2.0.jar">下载</a> <strong>FIRRTL</strong> 到项目的根目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ wget https://github.com/colin4124/chisel3-releases/releases/download/firrtl-1.2.0/firrtl-1.2.0.jar
$ java -cp firrtl-1.2.0.jar firrtl.stage.FirrtlMain -i Mux2.fir -o Mux.v</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">咧威</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-11-30
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        
        
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:colin4124@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/colin4124" class="iconfont icon-github" title="github"></a>
  <a href="http://funwo.ml/build-chisel-from-scratch/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">咧威</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="http://funwo.ml/build-chisel-from-scratch/js/feather.min.js"></script>
<script>
 feather.replace()
</script>


  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/build-chisel-from-scratch/dist/even.26188efa.min.js"></script>








</body>
</html>
